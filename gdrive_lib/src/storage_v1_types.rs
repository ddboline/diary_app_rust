#![allow(unused_variables, unused_mut, dead_code, non_camel_case_types)]
#![allow(clippy::redundant_else)]
#![allow(clippy::useless_format)]
#![allow(clippy::doc_markdown)]
#![allow(clippy::needless_return)]
#![allow(clippy::single_char_pattern)]
#![allow(clippy::into_iter_on_ref)]
#![allow(clippy::wildcard_imports)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::try_err)]
//! This file was generated by async-google-apis. (https://github.com/dermesser/async-google-apis)
//!
//! (c) 2020 Lewin Bormann <lbo@spheniscida.de>
//!
//! ## Getting started
//!
//! **Tip**: Take a look at those types ending in `...Service`. These represent
//! API resources and contain methods to interact with an API. The remaining
//! types are used by those methods and can be explored starting from a method
//! you want to use.
//!
//! The generated code's dependencies are in the `async-google-apis-common`
//! crate. The main dependencies are hyper, yup-oauth2 (for OAuth
//! authentication), and serde.
//!
//! I'd be happy if you let me know about your use case of this code.
//!
//! THIS FILE HAS BEEN GENERATED -- SAVE ANY MODIFICATIONS BEFORE REPLACING.

use async_google_apis_common::*;

/// Scopes of this API. Convertible to their string representation with `AsRef`.
#[derive(Debug, Clone, Copy)]
pub enum StorageScopes {
    /// View and manage your data across Google Cloud Platform services
    ///
    /// URL: https://www.googleapis.com/auth/cloud-platform
    CloudPlatform,
    /// View your data across Google Cloud Platform services
    ///
    /// URL: https://www.googleapis.com/auth/cloud-platform.read-only
    CloudPlatformReadOnly,
    /// Manage your data and permissions in Google Cloud Storage
    ///
    /// URL: https://www.googleapis.com/auth/devstorage.full_control
    DevstorageFullControl,
    /// View your data in Google Cloud Storage
    ///
    /// URL: https://www.googleapis.com/auth/devstorage.read_only
    DevstorageReadOnly,
    /// Manage your data in Google Cloud Storage
    ///
    /// URL: https://www.googleapis.com/auth/devstorage.read_write
    DevstorageReadWrite,
}

impl std::convert::AsRef<str> for StorageScopes {
    fn as_ref(&self) -> &'static str {
        match self {
            StorageScopes::CloudPlatform => "https://www.googleapis.com/auth/cloud-platform",
            StorageScopes::CloudPlatformReadOnly => {
                "https://www.googleapis.com/auth/cloud-platform.read-only"
            }
            StorageScopes::DevstorageFullControl => {
                "https://www.googleapis.com/auth/devstorage.full_control"
            }
            StorageScopes::DevstorageReadOnly => {
                "https://www.googleapis.com/auth/devstorage.read_only"
            }
            StorageScopes::DevstorageReadWrite => {
                "https://www.googleapis.com/auth/devstorage.read_write"
            }
        }
    }
}

/// The bucket's billing configuration.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketBilling {
    /// When set to true, Requester Pays is enabled for this bucket.
    #[serde(rename = "requesterPays")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_pays: Option<bool>,
}

///
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketCors {
    /// The value, in seconds, to return in the  Access-Control-Max-Age header
    /// used in preflight responses.
    #[serde(rename = "maxAgeSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_age_seconds: Option<i32>,
    /// The list of HTTP methods on which to include CORS response headers,
    /// (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods,
    /// and means "any method".
    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<Vec<String>>,
    /// The list of Origins eligible to receive CORS response headers. Note: "*"
    /// is permitted in the list of origins, and means "any Origin".
    #[serde(rename = "origin")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub origin: Option<Vec<String>>,
    /// The list of HTTP headers other than the simple response headers to give
    /// permission for the user-agent to share across domains.
    #[serde(rename = "responseHeader")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response_header: Option<Vec<String>>,
}

/// Encryption configuration for a bucket.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketEncryption {
    /// A Cloud KMS key that will be used to encrypt objects inserted into this
    /// bucket, if no encryption method is specified.
    #[serde(rename = "defaultKmsKeyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_kms_key_name: Option<String>,
}

/// The bucket's uniform bucket-level access configuration. The feature was
/// formerly known as Bucket Policy Only. For backward compatibility, this field
/// will be populated with identical information as the uniformBucketLevelAccess
/// field. We recommend using the uniformBucketLevelAccess field to enable and
/// disable the feature.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketIamConfigurationBucketPolicyOnly {
    /// If set, access is controlled only by bucket-level or above IAM policies.
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// DateTime: The deadline for changing
    /// iamConfiguration.bucketPolicyOnly.enabled from true to false in RFC 3339
    /// format. iamConfiguration.bucketPolicyOnly.enabled may be changed from
    /// true to false until the locked time, after which the field is immutable.
    #[serde(rename = "lockedTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locked_time: Option<DateTime<Utc>>,
}

/// The bucket's uniform bucket-level access configuration.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketIamConfigurationUniformBucketLevelAccess {
    /// If set, access is controlled only by bucket-level or above IAM policies.
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// DateTime: The deadline for changing
    /// iamConfiguration.uniformBucketLevelAccess.enabled from true to false in
    /// RFC 3339  format. iamConfiguration.uniformBucketLevelAccess.enabled may
    /// be changed from true to false until the locked time, after which the
    /// field is immutable.
    #[serde(rename = "lockedTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locked_time: Option<DateTime<Utc>>,
}

/// The bucket's IAM configuration.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketIamConfiguration {
    /// The bucket's uniform bucket-level access configuration. The feature was
    /// formerly known as Bucket Policy Only. For backward compatibility, this
    /// field will be populated with identical information as the
    /// uniformBucketLevelAccess field. We recommend using the
    /// uniformBucketLevelAccess field to enable and disable the feature.
    #[serde(rename = "bucketPolicyOnly")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bucket_policy_only: Option<BucketIamConfigurationBucketPolicyOnly>,
    /// The bucket's uniform bucket-level access configuration.
    #[serde(rename = "uniformBucketLevelAccess")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uniform_bucket_level_access: Option<BucketIamConfigurationUniformBucketLevelAccess>,
    /// The bucket's Public Access Prevention configuration. Currently,
    /// 'unspecified' and 'enforced' are supported.
    #[serde(rename = "publicAccessPrevention")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public_access_prevention: Option<String>,
}

/// The action to take.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketLifecycleRuleAction {
    /// Target storage class. Required iff the type of the action is
    /// SetStorageClass.
    #[serde(rename = "storageClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub storage_class: Option<String>,
    /// Type of the action. Currently, only Delete and SetStorageClass are
    /// supported.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub typ: Option<String>,
}

/// The condition(s) under which the action will be taken.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketLifecycleRuleCondition {
    /// Age of an object (in days). This condition is satisfied when an object
    /// reaches the specified age.
    #[serde(rename = "age")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age: Option<i32>,
    /// A date in RFC 3339 format with only the date part (for instance,
    /// "2013-01-15"). This condition is satisfied when an object is created
    /// before midnight of the specified date in UTC.
    #[serde(rename = "createdBefore")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_before: Option<String>,
    /// A date in RFC 3339 format with only the date part (for instance,
    /// "2013-01-15"). This condition is satisfied when the custom time on an
    /// object is before this date in UTC.
    #[serde(rename = "customTimeBefore")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_time_before: Option<String>,
    /// Number of days elapsed since the user-specified timestamp set on an
    /// object. The condition is satisfied if the days elapsed is at least this
    /// number. If no custom timestamp is specified on an object, the condition
    /// does not apply.
    #[serde(rename = "daysSinceCustomTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_since_custom_time: Option<i32>,
    /// Number of days elapsed since the noncurrent timestamp of an object. The
    /// condition is satisfied if the days elapsed is at least this number. This
    /// condition is relevant only for versioned objects. The value of the field
    /// must be a nonnegative integer. If it's zero, the object version will
    /// become eligible for Lifecycle action as soon as it becomes noncurrent.
    #[serde(rename = "daysSinceNoncurrentTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_since_noncurrent_time: Option<i32>,
    /// Relevant only for versioned objects. If the value is true, this
    /// condition matches live objects; if the value is false, it matches
    /// archived objects.
    #[serde(rename = "isLive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_live: Option<bool>,
    /// A regular expression that satisfies the RE2 syntax. This condition is
    /// satisfied when the name of the object matches the RE2 pattern. Note:
    /// This feature is currently in the "Early Access" launch stage and is only
    /// available to a whitelisted set of users; that means that this feature
    /// may be changed in backward-incompatible ways and that it is not
    /// guaranteed to be released.
    #[serde(rename = "matchesPattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub matches_pattern: Option<String>,
    /// Objects having any of the storage classes specified by this condition
    /// will be matched. Values include MULTI_REGIONAL, REGIONAL, NEARLINE,
    /// COLDLINE, ARCHIVE, STANDARD, and DURABLE_REDUCED_AVAILABILITY.
    #[serde(rename = "matchesStorageClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub matches_storage_class: Option<Vec<String>>,
    /// A date in RFC 3339 format with only the date part (for instance,
    /// "2013-01-15"). This condition is satisfied when the noncurrent time on
    /// an object is before this date in UTC. This condition is relevant only
    /// for versioned objects.
    #[serde(rename = "noncurrentTimeBefore")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub noncurrent_time_before: Option<String>,
    /// Relevant only for versioned objects. If the value is N, this condition
    /// is satisfied when there are at least N versions (including the live
    /// version) newer than this version of the object.
    #[serde(rename = "numNewerVersions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub num_newer_versions: Option<i32>,
}

///
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketLifecycleRule {
    /// The action to take.
    #[serde(rename = "action")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<BucketLifecycleRuleAction>,
    /// The condition(s) under which the action will be taken.
    #[serde(rename = "condition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub condition: Option<BucketLifecycleRuleCondition>,
}

/// The bucket's lifecycle configuration. See lifecycle management for more
/// information.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketLifecycle {
    /// A lifecycle management rule, which is made of an action to take and the
    /// condition(s) under which the action will be taken.
    #[serde(rename = "rule")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule: Option<Vec<BucketLifecycleRule>>,
}

/// The bucket's logging configuration, which defines the destination bucket and
/// optional name prefix for the current bucket's logs.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketLogging {
    /// The destination bucket where the current bucket's logs should be placed.
    #[serde(rename = "logBucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_bucket: Option<String>,
    /// A prefix for log object names.
    #[serde(rename = "logObjectPrefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_object_prefix: Option<String>,
}

/// The owner of the bucket. This is always the project team's owner group.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketOwner {
    /// The entity, in the form project-owner-projectId.
    #[serde(rename = "entity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity: Option<String>,
    /// The ID for the entity.
    #[serde(rename = "entityId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<String>,
}

/// The bucket's retention policy. The retention policy enforces a minimum
/// retention time for all objects contained in the bucket, based on their
/// creation time. Any attempt to overwrite or delete objects younger than the
/// retention period will result in a PERMISSION_DENIED error. An unlocked
/// retention policy can be modified or removed from the bucket via a
/// storage.buckets.update operation. A locked retention policy cannot be
/// removed or shortened in duration for the lifetime of the bucket. Attempting
/// to remove or decrease period of a locked retention policy will result in a
/// PERMISSION_DENIED error.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketRetentionPolicy {
    /// DateTime: Server-determined value that indicates the time from which
    /// policy was enforced and effective. This value is in RFC 3339 format.
    #[serde(rename = "effectiveTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub effective_time: Option<DateTime<Utc>>,
    /// Once locked, an object retention policy cannot be modified.
    #[serde(rename = "isLocked")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_locked: Option<bool>,
    /// i64: The duration in seconds that objects need to be retained. Retention
    /// duration must be greater than zero and less than 100 years. Note that
    /// enforcement of retention periods less than a day is not guaranteed. Such
    /// periods should only be used for testing purposes.
    #[serde(rename = "retentionPeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_period: Option<String>,
}

/// The bucket's versioning configuration.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketVersioning {
    /// While set to true, versioning is fully enabled for this bucket.
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The bucket's website configuration, controlling how the service behaves when
/// accessing bucket contents as a web site. See the Static Website Examples for
/// more information.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketWebsite {
    /// If the requested object path is missing, the service will ensure the
    /// path has a trailing '/', append this suffix, and attempt to retrieve the
    /// resulting object. This allows the creation of index.html objects to
    /// represent directory pages.
    #[serde(rename = "mainPageSuffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub main_page_suffix: Option<String>,
    /// If the requested object path is missing, and any mainPageSuffix object
    /// is missing, if applicable, the service will return the named object from
    /// this bucket as the content for a 404 Not Found result.
    #[serde(rename = "notFoundPage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_found_page: Option<String>,
}

/// A bucket.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Bucket {
    /// Access controls on the bucket.
    #[serde(rename = "acl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acl: Option<Vec<BucketAccessControl>>,
    /// The bucket's billing configuration.
    #[serde(rename = "billing")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing: Option<BucketBilling>,
    /// The bucket's Cross-Origin Resource Sharing (CORS) configuration.
    #[serde(rename = "cors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cors: Option<Vec<BucketCors>>,
    /// The default value for event-based hold on newly created objects in this
    /// bucket. Event-based hold is a way to retain objects indefinitely until
    /// an event occurs, signified by the hold's release. After being released,
    /// such objects will be subject to bucket-level retention (if any). One
    /// sample use case of this flag is for banks to hold loan documents for at
    /// least 3 years after loan is paid in full. Here, bucket-level retention
    /// is 3 years and the event is loan being paid in full. In this example,
    /// these objects will be held intact for any number of years until the
    /// event has occurred (event-based hold on the object is released) and then
    /// 3 more years after that. That means retention duration of the objects
    /// begins from the moment event-based hold transitioned from true to false.
    /// Objects under event-based hold cannot be deleted, overwritten or
    /// archived until the hold is removed.
    #[serde(rename = "defaultEventBasedHold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_event_based_hold: Option<bool>,
    /// Default access controls to apply to new objects when no ACL is provided.
    #[serde(rename = "defaultObjectAcl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_object_acl: Option<Vec<ObjectAccessControl>>,
    /// Encryption configuration for a bucket.
    #[serde(rename = "encryption")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption: Option<BucketEncryption>,
    /// HTTP 1.1 Entity tag for the bucket.
    #[serde(rename = "etag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// The bucket's IAM configuration.
    #[serde(rename = "iamConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iam_configuration: Option<BucketIamConfiguration>,
    /// The ID of the bucket. For buckets, the id and name properties are the
    /// same.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The kind of item this is. For buckets, this is always storage#bucket.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// User-provided labels, in key/value pairs.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub labels: Option<HashMap<String, String>>,
    /// The bucket's lifecycle configuration. See lifecycle management for more
    /// information.
    #[serde(rename = "lifecycle")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<BucketLifecycle>,
    /// The location of the bucket. Object data for objects in the bucket
    /// resides in physical storage within this region. Defaults to US. See the
    /// developer's guide for the authoritative list.
    #[serde(rename = "location")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// The type of the bucket location.
    #[serde(rename = "locationType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location_type: Option<String>,
    /// The bucket's logging configuration, which defines the destination bucket
    /// and optional name prefix for the current bucket's logs.
    #[serde(rename = "logging")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging: Option<BucketLogging>,
    /// i64: The metadata generation of this bucket.
    #[serde(rename = "metageneration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metageneration: Option<String>,
    /// The name of the bucket.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The owner of the bucket. This is always the project team's owner group.
    #[serde(rename = "owner")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner: Option<BucketOwner>,
    /// u64: The project number of the project the bucket belongs to.
    #[serde(rename = "projectNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project_number: Option<String>,
    /// The bucket's retention policy. The retention policy enforces a minimum
    /// retention time for all objects contained in the bucket, based on their
    /// creation time. Any attempt to overwrite or delete objects younger than
    /// the retention period will result in a PERMISSION_DENIED error. An
    /// unlocked retention policy can be modified or removed from the bucket via
    /// a storage.buckets.update operation. A locked retention policy cannot be
    /// removed or shortened in duration for the lifetime of the bucket.
    /// Attempting to remove or decrease period of a locked retention policy
    /// will result in a PERMISSION_DENIED error.
    #[serde(rename = "retentionPolicy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<BucketRetentionPolicy>,
    /// The URI of this bucket.
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub self_link: Option<String>,
    /// The bucket's default storage class, used whenever no storageClass is
    /// specified for a newly-created object. This defines how objects in the
    /// bucket are stored and determines the SLA and the cost of storage. Values
    /// include MULTI_REGIONAL, REGIONAL, STANDARD, NEARLINE, COLDLINE, ARCHIVE,
    /// and DURABLE_REDUCED_AVAILABILITY. If this value is not specified when
    /// the bucket is created, it will default to STANDARD. For more
    /// information, see storage classes.
    #[serde(rename = "storageClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub storage_class: Option<String>,
    /// DateTime: The creation time of the bucket in RFC 3339 format.
    #[serde(rename = "timeCreated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_created: Option<DateTime<Utc>>,
    /// DateTime: The modification time of the bucket in RFC 3339 format.
    #[serde(rename = "updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<DateTime<Utc>>,
    /// The bucket's versioning configuration.
    #[serde(rename = "versioning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub versioning: Option<BucketVersioning>,
    /// The bucket's website configuration, controlling how the service behaves
    /// when accessing bucket contents as a web site. See the Static Website
    /// Examples for more information.
    #[serde(rename = "website")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub website: Option<BucketWebsite>,
    /// The zone or zones from which the bucket is intended to use zonal quota.
    /// Requests for data from outside the specified affinities are still
    /// allowed but won't be able to use zonal quota. The zone or zones need to
    /// be within the bucket location otherwise the requests will fail with a
    /// 400 Bad Request response.
    #[serde(rename = "zoneAffinity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub zone_affinity: Option<Vec<String>>,
    /// Reserved for future use.
    #[serde(rename = "satisfiesPZS")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub satisfies_p_z_s: Option<bool>,
}

/// The project team associated with the entity, if any.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControlProjectTeam {
    /// The project number.
    #[serde(rename = "projectNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project_number: Option<String>,
    /// The team.
    #[serde(rename = "team")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<String>,
}

/// An access-control entry.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControl {
    /// The name of the bucket.
    #[serde(rename = "bucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// The domain associated with the entity, if any.
    #[serde(rename = "domain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// The email address associated with the entity, if any.
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    /// The entity holding the permission, in one of the following forms:  -
    /// user-userId  - user-email  - group-groupId  - group-email  -
    /// domain-domain  - project-team-projectId  - allUsers  -
    /// allAuthenticatedUsers Examples:  - The user liz@example.com would be
    /// user-liz@example.com.  - The group example@googlegroups.com would be
    /// group-example@googlegroups.com.  - To refer to all members of the Google
    /// Apps for Business domain example.com, the entity would be
    /// domain-example.com.
    #[serde(rename = "entity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity: Option<String>,
    /// The ID for the entity, if any.
    #[serde(rename = "entityId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<String>,
    /// HTTP 1.1 Entity tag for the access-control entry.
    #[serde(rename = "etag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// The ID of the access-control entry.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The kind of item this is. For bucket access control entries, this is
    /// always storage#bucketAccessControl.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The project team associated with the entity, if any.
    #[serde(rename = "projectTeam")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project_team: Option<BucketAccessControlProjectTeam>,
    /// The access permission for the entity.
    #[serde(rename = "role")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// The link to this access-control entry.
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub self_link: Option<String>,
}

/// An access-control list.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControls {
    /// The list of items.
    #[serde(rename = "items")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<BucketAccessControl>>,
    /// The kind of item this is. For lists of bucket access control entries,
    /// this is always storage#bucketAccessControls.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
}

/// A list of buckets.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Buckets {
    /// The list of items.
    #[serde(rename = "items")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<Bucket>>,
    /// The kind of item this is. For lists of buckets, this is always
    /// storage#buckets.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// An notification channel used to watch for resource changes.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Channel {
    /// The address where notifications are delivered for this channel.
    #[serde(rename = "address")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    /// i64: Date and time of notification channel expiration, expressed as a
    /// Unix timestamp, in milliseconds. Optional.
    #[serde(rename = "expiration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiration: Option<String>,
    /// A UUID or similar unique string that identifies this channel.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Identifies this as a notification channel used to watch for changes to a
    /// resource, which is "api#channel".
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Additional parameters controlling delivery channel behavior. Optional.
    #[serde(rename = "params")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<HashMap<String, String>>,
    /// A Boolean value to indicate whether payload is wanted. Optional.
    #[serde(rename = "payload")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payload: Option<bool>,
    /// An opaque ID that identifies the resource being watched on this channel.
    /// Stable across different API versions.
    #[serde(rename = "resourceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    /// A version-specific identifier for the watched resource.
    #[serde(rename = "resourceUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_uri: Option<String>,
    /// An arbitrary string delivered to the target address with each
    /// notification delivered over this channel. Optional.
    #[serde(rename = "token")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// The type of delivery mechanism used for this channel.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub typ: Option<String>,
}

/// Conditions that must be met for this operation to execute.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ComposeRequestSourceObjectsObjectPreconditions {
    /// i64: Only perform the composition if the generation of the source object
    /// that would be used matches this value. If this value and a generation
    /// are both specified, they must be the same value or the call will fail.
    #[serde(rename = "ifGenerationMatch")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub if_generation_match: Option<String>,
}

///
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ComposeRequestSourceObjects {
    /// i64: The generation of this object to use as the source.
    #[serde(rename = "generation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation: Option<String>,
    /// The source object's name. All source objects must reside in the same
    /// bucket.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Conditions that must be met for this operation to execute.
    #[serde(rename = "objectPreconditions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object_preconditions: Option<ComposeRequestSourceObjectsObjectPreconditions>,
}

/// A Compose request.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ComposeRequest {
    #[serde(rename = "destination")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destination: Option<Object>,
    /// The kind of item this is.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The list of source objects that will be concatenated into a single
    /// object.
    #[serde(rename = "sourceObjects")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_objects: Option<Vec<ComposeRequestSourceObjects>>,
}

/// Represents an expression text. Example: title: "User account presence"
/// description: "Determines whether the request has a user account" expression:
/// "size(request.user) > 0"
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Expr {
    /// An optional description of the expression. This is a longer text which
    /// describes the expression, e.g. when hovered over it in a UI.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Textual representation of an expression in Common Expression Language
    /// syntax. The application context of the containing message determines
    /// which well-known feature set of CEL is supported.
    #[serde(rename = "expression")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
    /// An optional string indicating the location of the expression for error
    /// reporting, e.g. a file name and a position in the file.
    #[serde(rename = "location")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<String>,
    /// An optional title for the expression, i.e. a short string describing its
    /// purpose. This can be used e.g. in UIs which allow to enter the
    /// expression.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

/// JSON template to produce a JSON-style HMAC Key resource for Create
/// responses.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct HmacKey {
    /// The kind of item this is. For HMAC keys, this is always storage#hmacKey.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HmacKeyMetadata>,
    /// HMAC secret key material.
    #[serde(rename = "secret")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
}

/// JSON template to produce a JSON-style HMAC Key metadata resource.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct HmacKeyMetadata {
    /// The ID of the HMAC Key.
    #[serde(rename = "accessId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_id: Option<String>,
    /// HTTP 1.1 Entity tag for the HMAC key.
    #[serde(rename = "etag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// The ID of the HMAC key, including the Project ID and the Access ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The kind of item this is. For HMAC Key metadata, this is always
    /// storage#hmacKeyMetadata.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Project ID owning the service account to which the key authenticates.
    #[serde(rename = "projectId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project_id: Option<String>,
    /// The link to this resource.
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub self_link: Option<String>,
    /// The email address of the key's associated service account.
    #[serde(rename = "serviceAccountEmail")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_account_email: Option<String>,
    /// The state of the key. Can be one of ACTIVE, INACTIVE, or DELETED.
    #[serde(rename = "state")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    /// DateTime: The creation time of the HMAC key in RFC 3339 format.
    #[serde(rename = "timeCreated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_created: Option<DateTime<Utc>>,
    /// DateTime: The last modification time of the HMAC key metadata in RFC
    /// 3339 format.
    #[serde(rename = "updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<DateTime<Utc>>,
}

/// A list of hmacKeys.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct HmacKeysMetadata {
    /// The list of items.
    #[serde(rename = "items")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<HmacKeyMetadata>>,
    /// The kind of item this is. For lists of hmacKeys, this is always
    /// storage#hmacKeysMetadata.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
}

/// A subscription to receive Google PubSub notifications.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Notification {
    /// An optional list of additional attributes to attach to each Cloud PubSub
    /// message published for this notification subscription.
    #[serde(rename = "custom_attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_attributes: Option<HashMap<String, String>>,
    /// HTTP 1.1 Entity tag for this subscription notification.
    #[serde(rename = "etag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// If present, only send notifications about listed event types. If empty,
    /// sent notifications for all event types.
    #[serde(rename = "event_types")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_types: Option<Vec<String>>,
    /// The ID of the notification.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The kind of item this is. For notifications, this is always
    /// storage#notification.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// If present, only apply this notification configuration to object names
    /// that begin with this prefix.
    #[serde(rename = "object_name_prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object_name_prefix: Option<String>,
    /// The desired content of the Payload.
    #[serde(rename = "payload_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payload_format: Option<String>,
    /// The canonical URL of this notification.
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub self_link: Option<String>,
    /// The Cloud PubSub topic to which this subscription publishes. Formatted
    /// as: '//pubsub.googleapis.com/projects/{project-identifier}/topics/
    /// {my-topic}'
    #[serde(rename = "topic")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// A list of notification subscriptions.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Notifications {
    /// The list of items.
    #[serde(rename = "items")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<Notification>>,
    /// The kind of item this is. For lists of notifications, this is always
    /// storage#notifications.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
}

/// Metadata of customer-supplied encryption key, if the object is encrypted by
/// such a key.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectCustomerEncryption {
    /// The encryption algorithm.
    #[serde(rename = "encryptionAlgorithm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption_algorithm: Option<String>,
    /// SHA256 hash value of the encryption key.
    #[serde(rename = "keySha256")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_sha256: Option<String>,
}

/// The owner of the object. This will always be the uploader of the object.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectOwner {
    /// The entity, in the form user-userId.
    #[serde(rename = "entity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity: Option<String>,
    /// The ID for the entity.
    #[serde(rename = "entityId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<String>,
}

/// An object.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Object {
    /// Access controls on the object.
    #[serde(rename = "acl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acl: Option<Vec<ObjectAccessControl>>,
    /// The name of the bucket containing this object.
    #[serde(rename = "bucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// Cache-Control directive for the object data. If omitted, and the object
    /// is accessible to all anonymous users, the default will be public,
    /// max-age=3600.
    #[serde(rename = "cacheControl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<String>,
    /// Number of underlying components that make up this object. Components are
    /// accumulated by compose operations.
    #[serde(rename = "componentCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub component_count: Option<i32>,
    /// Content-Disposition of the object data.
    #[serde(rename = "contentDisposition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_disposition: Option<String>,
    /// Content-Encoding of the object data.
    #[serde(rename = "contentEncoding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_encoding: Option<String>,
    /// Content-Language of the object data.
    #[serde(rename = "contentLanguage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_language: Option<String>,
    /// Content-Type of the object data. If an object is stored without a
    /// Content-Type, it is served as application/octet-stream.
    #[serde(rename = "contentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,
    /// CRC32c checksum, as described in RFC 4960, Appendix B; encoded using
    /// base64 in big-endian byte order. For more information about using the
    /// CRC32c checksum, see Hashes and ETags: Best Practices.
    #[serde(rename = "crc32c")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub crc32c: Option<String>,
    /// DateTime: A timestamp in RFC 3339 format specified by the user for an
    /// object.
    #[serde(rename = "customTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_time: Option<DateTime<Utc>>,
    /// Metadata of customer-supplied encryption key, if the object is encrypted
    /// by such a key.
    #[serde(rename = "customerEncryption")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer_encryption: Option<ObjectCustomerEncryption>,
    /// HTTP 1.1 Entity tag for the object.
    #[serde(rename = "etag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// Whether an object is under event-based hold. Event-based hold is a way
    /// to retain objects until an event occurs, which is signified by the
    /// hold's release (i.e. this value is set to false). After being released
    /// (set to false), such objects will be subject to bucket-level retention
    /// (if any). One sample use case of this flag is for banks to hold loan
    /// documents for at least 3 years after loan is paid in full. Here,
    /// bucket-level retention is 3 years and the event is the loan being paid
    /// in full. In this example, these objects will be held intact for any
    /// number of years until the event has occurred (event-based hold on the
    /// object is released) and then 3 more years after that. That means
    /// retention duration of the objects begins from the moment event-based
    /// hold transitioned from true to false.
    #[serde(rename = "eventBasedHold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_based_hold: Option<bool>,
    /// i64: The content generation of this object. Used for object versioning.
    #[serde(rename = "generation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation: Option<String>,
    /// The ID of the object, including the bucket name, object name, and
    /// generation number.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The kind of item this is. For objects, this is always storage#object.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Not currently supported. Specifying the parameter causes the request to
    /// fail with status code 400 - Bad Request.
    #[serde(rename = "kmsKeyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kms_key_name: Option<String>,
    /// MD5 hash of the data; encoded using base64. For more information about
    /// using the MD5 hash, see Hashes and ETags: Best Practices.
    #[serde(rename = "md5Hash")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub md5_hash: Option<String>,
    /// Media download link.
    #[serde(rename = "mediaLink")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub media_link: Option<String>,
    /// User-provided metadata, in key/value pairs.
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    /// i64: The version of the metadata for this object at this generation.
    /// Used for preconditions and for detecting changes in metadata. A
    /// metageneration number is only meaningful in the context of a particular
    /// generation of a particular object.
    #[serde(rename = "metageneration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metageneration: Option<String>,
    /// The name of the object. Required if not specified by URL parameter.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The owner of the object. This will always be the uploader of the object.
    #[serde(rename = "owner")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner: Option<ObjectOwner>,
    /// DateTime: A server-determined value that specifies the earliest time
    /// that the object's retention period expires. This value is in RFC 3339
    /// format. Note 1: This field is not provided for objects with an active
    /// event-based hold, since retention expiration is unknown until the hold
    /// is removed. Note 2: This value can be provided even when temporary hold
    /// is set (so that the user can reason about policy without having to first
    /// unset the temporary hold).
    #[serde(rename = "retentionExpirationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_expiration_time: Option<DateTime<Utc>>,
    /// The link to this object.
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub self_link: Option<String>,
    /// u64: Content-Length of the data in bytes.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
    /// Storage class of the object.
    #[serde(rename = "storageClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub storage_class: Option<String>,
    /// Whether an object is under temporary hold. While this flag is set to
    /// true, the object is protected against deletion and overwrites. A common
    /// use case of this flag is regulatory investigations where objects need to
    /// be retained while the investigation is ongoing. Note that unlike
    /// event-based hold, temporary hold does not impact retention expiration
    /// time of an object.
    #[serde(rename = "temporaryHold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporary_hold: Option<bool>,
    /// DateTime: The creation time of the object in RFC 3339 format.
    #[serde(rename = "timeCreated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_created: Option<DateTime<Utc>>,
    /// DateTime: The deletion time of the object in RFC 3339 format. Will be
    /// returned if and only if this version of the object has been deleted.
    #[serde(rename = "timeDeleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_deleted: Option<DateTime<Utc>>,
    /// DateTime: The time at which the object's storage class was last changed.
    /// When the object is initially created, it will be set to timeCreated.
    #[serde(rename = "timeStorageClassUpdated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_storage_class_updated: Option<DateTime<Utc>>,
    /// DateTime: The modification time of the object metadata in RFC 3339
    /// format.
    #[serde(rename = "updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<DateTime<Utc>>,
}

/// The project team associated with the entity, if any.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControlProjectTeam {
    /// The project number.
    #[serde(rename = "projectNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project_number: Option<String>,
    /// The team.
    #[serde(rename = "team")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<String>,
}

/// An access-control entry.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControl {
    /// The name of the bucket.
    #[serde(rename = "bucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// The domain associated with the entity, if any.
    #[serde(rename = "domain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// The email address associated with the entity, if any.
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    /// The entity holding the permission, in one of the following forms:  -
    /// user-userId  - user-email  - group-groupId  - group-email  -
    /// domain-domain  - project-team-projectId  - allUsers  -
    /// allAuthenticatedUsers Examples:  - The user liz@example.com would be
    /// user-liz@example.com.  - The group example@googlegroups.com would be
    /// group-example@googlegroups.com.  - To refer to all members of the Google
    /// Apps for Business domain example.com, the entity would be
    /// domain-example.com.
    #[serde(rename = "entity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity: Option<String>,
    /// The ID for the entity, if any.
    #[serde(rename = "entityId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entity_id: Option<String>,
    /// HTTP 1.1 Entity tag for the access-control entry.
    #[serde(rename = "etag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// i64: The content generation of the object, if applied to an object.
    #[serde(rename = "generation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation: Option<String>,
    /// The ID of the access-control entry.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The kind of item this is. For object access control entries, this is
    /// always storage#objectAccessControl.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The name of the object, if applied to an object.
    #[serde(rename = "object")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object: Option<String>,
    /// The project team associated with the entity, if any.
    #[serde(rename = "projectTeam")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project_team: Option<ObjectAccessControlProjectTeam>,
    /// The access permission for the entity.
    #[serde(rename = "role")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    /// The link to this access-control entry.
    #[serde(rename = "selfLink")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub self_link: Option<String>,
}

/// An access-control list.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControls {
    /// The list of items.
    #[serde(rename = "items")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<ObjectAccessControl>>,
    /// The kind of item this is. For lists of object access control entries,
    /// this is always storage#objectAccessControls.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
}

/// A list of objects.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Objects {
    /// The list of items.
    #[serde(rename = "items")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub items: Option<Vec<Object>>,
    /// The kind of item this is. For lists of objects, this is always
    /// storage#objects.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[serde(rename = "nextPageToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_token: Option<String>,
    /// The list of prefixes of objects matching-but-not-listed up to and
    /// including the requested delimiter.
    #[serde(rename = "prefixes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefixes: Option<Vec<String>>,
}

///
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct PolicyBindings {
    #[serde(rename = "condition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub condition: Option<Expr>,
    /// A collection of identifiers for members who may assume the provided
    /// role. Recognized identifiers are as follows:   - allUsers — A special
    /// identifier that represents anyone on the internet; with or without a
    /// Google account.   - allAuthenticatedUsers — A special identifier that
    /// represents anyone who is authenticated with a Google account or a
    /// service account.   - user:emailid — An email address that represents a
    /// specific account. For example, user:alice@gmail.com or
    /// user:joe@example.com.   - serviceAccount:emailid — An email address that
    /// represents a service account. For example,
    /// serviceAccount:my-other-app@appspot.gserviceaccount.com .   -
    /// group:emailid — An email address that represents a Google group. For
    /// example, group:admins@example.com.   - domain:domain — A Google Apps
    /// domain name that represents all the users of that domain. For example,
    /// domain:google.com or domain:example.com.   - projectOwner:projectid —
    /// Owners of the given project. For example,
    /// projectOwner:my-example-project   - projectEditor:projectid — Editors of
    /// the given project. For example, projectEditor:my-example-project   -
    /// projectViewer:projectid — Viewers of the given project. For example,
    /// projectViewer:my-example-project
    #[serde(rename = "members")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub members: Option<Vec<String>>,
    /// The role to which members belong. Two types of roles are supported: new
    /// IAM roles, which grant permissions that do not map directly to those
    /// provided by ACLs, and legacy IAM roles, which do map directly to ACL
    /// permissions. All roles are of the format roles/storage.specificRole. The
    /// new IAM roles are:   - roles/storage.admin — Full control of Google
    /// Cloud Storage resources.   - roles/storage.objectViewer — Read-Only
    /// access to Google Cloud Storage objects.   - roles/storage.objectCreator
    /// — Access to create objects in Google Cloud Storage.   -
    /// roles/storage.objectAdmin — Full control of Google Cloud Storage
    /// objects.   The legacy IAM roles are:   -
    /// roles/storage.legacyObjectReader — Read-only access to objects without
    /// listing. Equivalent to an ACL entry on an object with the READER role.
    /// - roles/storage.legacyObjectOwner — Read/write access to existing
    /// objects without listing. Equivalent to an ACL entry on an object with
    /// the OWNER role.   - roles/storage.legacyBucketReader — Read access to
    /// buckets with object listing. Equivalent to an ACL entry on a bucket with
    /// the READER role.   - roles/storage.legacyBucketWriter — Read access to
    /// buckets with object listing/creation/deletion. Equivalent to an ACL
    /// entry on a bucket with the WRITER role.   -
    /// roles/storage.legacyBucketOwner — Read and write access to existing
    /// buckets with object listing/creation/deletion. Equivalent to an ACL
    /// entry on a bucket with the OWNER role.
    #[serde(rename = "role")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

/// A bucket/object IAM policy.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Policy {
    /// An association between a role, which comes with a set of permissions,
    /// and members who may assume that role.
    #[serde(rename = "bindings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bindings: Option<Vec<PolicyBindings>>,
    /// HTTP 1.1  Entity tag for the policy.
    #[serde(rename = "etag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub etag: Option<String>,
    /// The kind of item this is. For policies, this is always storage#policy.
    /// This field is ignored on input.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The ID of the resource to which this policy belongs. Will be of the form
    /// projects/_/buckets/bucket for buckets, and
    /// projects/_/buckets/bucket/objects/object for objects. A specific
    /// generation may be specified by appending #generationNumber to the end of
    /// the object name, e.g. projects/_/buckets/my-bucket/objects/data.txt#17.
    /// The current generation can be denoted with #0. This field is ignored on
    /// input.
    #[serde(rename = "resourceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    /// The IAM policy format version.
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i32>,
}

/// A rewrite response.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct RewriteResponse {
    /// true if the copy is finished; otherwise, false if the copy is in
    /// progress. This property is always present in the response.
    #[serde(rename = "done")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub done: Option<bool>,
    /// The kind of item this is.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// i64: The total size of the object being copied in bytes. This property
    /// is always present in the response.
    #[serde(rename = "objectSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object_size: Option<String>,
    #[serde(rename = "resource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource: Option<Object>,
    /// A token to use in subsequent requests to continue copying data. This
    /// token is present in the response only when there is more data to copy.
    #[serde(rename = "rewriteToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rewrite_token: Option<String>,
    /// i64: The total bytes written so far, which can be used to provide a
    /// waiting user with a progress indicator. This property is always present
    /// in the response.
    #[serde(rename = "totalBytesRewritten")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_bytes_rewritten: Option<String>,
}

/// A subscription to receive Google PubSub notifications.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ServiceAccount {
    /// The ID of the notification.
    #[serde(rename = "email_address")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email_address: Option<String>,
    /// The kind of item this is. For notifications, this is always
    /// storage#notification.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
}

/// A storage.(buckets|objects).testIamPermissions response.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct TestIamPermissionsResponse {
    /// The kind of item this is.
    #[serde(rename = "kind")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// The permissions held by the caller. Permissions are always of the format
    /// storage.resource.capability, where resource is one of buckets or
    /// objects. The supported permissions are as follows:   -
    /// storage.buckets.delete — Delete bucket.   - storage.buckets.get — Read
    /// bucket metadata.   - storage.buckets.getIamPolicy — Read bucket IAM
    /// policy.   - storage.buckets.create — Create bucket.   -
    /// storage.buckets.list — List buckets.   - storage.buckets.setIamPolicy —
    /// Update bucket IAM policy.   - storage.buckets.update — Update bucket
    /// metadata.   - storage.objects.delete — Delete object.   -
    /// storage.objects.get — Read object data and metadata.   -
    /// storage.objects.getIamPolicy — Read object IAM policy.   -
    /// storage.objects.create — Create object.   - storage.objects.list — List
    /// objects.   - storage.objects.setIamPolicy — Update object IAM policy.
    /// - storage.objects.update — Update object metadata.
    #[serde(rename = "permissions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub permissions: Option<Vec<String>>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsGetProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit owner, acl and defaultObjectAcl properties.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for BucketsGetProjection {
    fn default() -> BucketsGetProjection {
        BucketsGetProjection::Undefined
    }
}

impl std::fmt::Display for BucketsGetProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsGetProjection::Undefined => write!(f, "undefined"),
            BucketsGetProjection::Full => write!(f, "full"),
            BucketsGetProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsInsertPredefinedAcl {
    Undefined,
    /// Project team owners get OWNER access, and allAuthenticatedUsers get
    /// READER access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Project team owners get OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Project team members get access according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Project team owners get OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
    /// Project team owners get OWNER access, and allUsers get WRITER access.
    #[serde(rename = "publicReadWrite")]
    PublicReadWrite,
}

impl std::default::Default for BucketsInsertPredefinedAcl {
    fn default() -> BucketsInsertPredefinedAcl {
        BucketsInsertPredefinedAcl::Undefined
    }
}

impl std::fmt::Display for BucketsInsertPredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsInsertPredefinedAcl::Undefined => write!(f, "undefined"),
            BucketsInsertPredefinedAcl::AuthenticatedRead => write!(f, "authenticatedRead"),
            BucketsInsertPredefinedAcl::Private => write!(f, "private"),
            BucketsInsertPredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            BucketsInsertPredefinedAcl::PublicRead => write!(f, "publicRead"),
            BucketsInsertPredefinedAcl::PublicReadWrite => write!(f, "publicReadWrite"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsInsertPredefinedDefaultObjectAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for BucketsInsertPredefinedDefaultObjectAcl {
    fn default() -> BucketsInsertPredefinedDefaultObjectAcl {
        BucketsInsertPredefinedDefaultObjectAcl::Undefined
    }
}

impl std::fmt::Display for BucketsInsertPredefinedDefaultObjectAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsInsertPredefinedDefaultObjectAcl::Undefined => write!(f, "undefined"),
            BucketsInsertPredefinedDefaultObjectAcl::AuthenticatedRead => {
                write!(f, "authenticatedRead")
            }
            BucketsInsertPredefinedDefaultObjectAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            BucketsInsertPredefinedDefaultObjectAcl::BucketOwnerRead => {
                write!(f, "bucketOwnerRead")
            }
            BucketsInsertPredefinedDefaultObjectAcl::Private => write!(f, "private"),
            BucketsInsertPredefinedDefaultObjectAcl::ProjectPrivate => write!(f, "projectPrivate"),
            BucketsInsertPredefinedDefaultObjectAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsInsertProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit owner, acl and defaultObjectAcl properties.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for BucketsInsertProjection {
    fn default() -> BucketsInsertProjection {
        BucketsInsertProjection::Undefined
    }
}

impl std::fmt::Display for BucketsInsertProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsInsertProjection::Undefined => write!(f, "undefined"),
            BucketsInsertProjection::Full => write!(f, "full"),
            BucketsInsertProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsListProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit owner, acl and defaultObjectAcl properties.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for BucketsListProjection {
    fn default() -> BucketsListProjection {
        BucketsListProjection::Undefined
    }
}

impl std::fmt::Display for BucketsListProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsListProjection::Undefined => write!(f, "undefined"),
            BucketsListProjection::Full => write!(f, "full"),
            BucketsListProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsPatchPredefinedAcl {
    Undefined,
    /// Project team owners get OWNER access, and allAuthenticatedUsers get
    /// READER access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Project team owners get OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Project team members get access according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Project team owners get OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
    /// Project team owners get OWNER access, and allUsers get WRITER access.
    #[serde(rename = "publicReadWrite")]
    PublicReadWrite,
}

impl std::default::Default for BucketsPatchPredefinedAcl {
    fn default() -> BucketsPatchPredefinedAcl {
        BucketsPatchPredefinedAcl::Undefined
    }
}

impl std::fmt::Display for BucketsPatchPredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsPatchPredefinedAcl::Undefined => write!(f, "undefined"),
            BucketsPatchPredefinedAcl::AuthenticatedRead => write!(f, "authenticatedRead"),
            BucketsPatchPredefinedAcl::Private => write!(f, "private"),
            BucketsPatchPredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            BucketsPatchPredefinedAcl::PublicRead => write!(f, "publicRead"),
            BucketsPatchPredefinedAcl::PublicReadWrite => write!(f, "publicReadWrite"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsPatchPredefinedDefaultObjectAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for BucketsPatchPredefinedDefaultObjectAcl {
    fn default() -> BucketsPatchPredefinedDefaultObjectAcl {
        BucketsPatchPredefinedDefaultObjectAcl::Undefined
    }
}

impl std::fmt::Display for BucketsPatchPredefinedDefaultObjectAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsPatchPredefinedDefaultObjectAcl::Undefined => write!(f, "undefined"),
            BucketsPatchPredefinedDefaultObjectAcl::AuthenticatedRead => {
                write!(f, "authenticatedRead")
            }
            BucketsPatchPredefinedDefaultObjectAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            BucketsPatchPredefinedDefaultObjectAcl::BucketOwnerRead => write!(f, "bucketOwnerRead"),
            BucketsPatchPredefinedDefaultObjectAcl::Private => write!(f, "private"),
            BucketsPatchPredefinedDefaultObjectAcl::ProjectPrivate => write!(f, "projectPrivate"),
            BucketsPatchPredefinedDefaultObjectAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsPatchProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit owner, acl and defaultObjectAcl properties.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for BucketsPatchProjection {
    fn default() -> BucketsPatchProjection {
        BucketsPatchProjection::Undefined
    }
}

impl std::fmt::Display for BucketsPatchProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsPatchProjection::Undefined => write!(f, "undefined"),
            BucketsPatchProjection::Full => write!(f, "full"),
            BucketsPatchProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsUpdatePredefinedAcl {
    Undefined,
    /// Project team owners get OWNER access, and allAuthenticatedUsers get
    /// READER access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Project team owners get OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Project team members get access according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Project team owners get OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
    /// Project team owners get OWNER access, and allUsers get WRITER access.
    #[serde(rename = "publicReadWrite")]
    PublicReadWrite,
}

impl std::default::Default for BucketsUpdatePredefinedAcl {
    fn default() -> BucketsUpdatePredefinedAcl {
        BucketsUpdatePredefinedAcl::Undefined
    }
}

impl std::fmt::Display for BucketsUpdatePredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsUpdatePredefinedAcl::Undefined => write!(f, "undefined"),
            BucketsUpdatePredefinedAcl::AuthenticatedRead => write!(f, "authenticatedRead"),
            BucketsUpdatePredefinedAcl::Private => write!(f, "private"),
            BucketsUpdatePredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            BucketsUpdatePredefinedAcl::PublicRead => write!(f, "publicRead"),
            BucketsUpdatePredefinedAcl::PublicReadWrite => write!(f, "publicReadWrite"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsUpdatePredefinedDefaultObjectAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for BucketsUpdatePredefinedDefaultObjectAcl {
    fn default() -> BucketsUpdatePredefinedDefaultObjectAcl {
        BucketsUpdatePredefinedDefaultObjectAcl::Undefined
    }
}

impl std::fmt::Display for BucketsUpdatePredefinedDefaultObjectAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsUpdatePredefinedDefaultObjectAcl::Undefined => write!(f, "undefined"),
            BucketsUpdatePredefinedDefaultObjectAcl::AuthenticatedRead => {
                write!(f, "authenticatedRead")
            }
            BucketsUpdatePredefinedDefaultObjectAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            BucketsUpdatePredefinedDefaultObjectAcl::BucketOwnerRead => {
                write!(f, "bucketOwnerRead")
            }
            BucketsUpdatePredefinedDefaultObjectAcl::Private => write!(f, "private"),
            BucketsUpdatePredefinedDefaultObjectAcl::ProjectPrivate => write!(f, "projectPrivate"),
            BucketsUpdatePredefinedDefaultObjectAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum BucketsUpdateProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit owner, acl and defaultObjectAcl properties.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for BucketsUpdateProjection {
    fn default() -> BucketsUpdateProjection {
        BucketsUpdateProjection::Undefined
    }
}

impl std::fmt::Display for BucketsUpdateProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            BucketsUpdateProjection::Undefined => write!(f, "undefined"),
            BucketsUpdateProjection::Full => write!(f, "full"),
            BucketsUpdateProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsComposeDestinationPredefinedAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for ObjectsComposeDestinationPredefinedAcl {
    fn default() -> ObjectsComposeDestinationPredefinedAcl {
        ObjectsComposeDestinationPredefinedAcl::Undefined
    }
}

impl std::fmt::Display for ObjectsComposeDestinationPredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsComposeDestinationPredefinedAcl::Undefined => write!(f, "undefined"),
            ObjectsComposeDestinationPredefinedAcl::AuthenticatedRead => {
                write!(f, "authenticatedRead")
            }
            ObjectsComposeDestinationPredefinedAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            ObjectsComposeDestinationPredefinedAcl::BucketOwnerRead => write!(f, "bucketOwnerRead"),
            ObjectsComposeDestinationPredefinedAcl::Private => write!(f, "private"),
            ObjectsComposeDestinationPredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            ObjectsComposeDestinationPredefinedAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsCopyDestinationPredefinedAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for ObjectsCopyDestinationPredefinedAcl {
    fn default() -> ObjectsCopyDestinationPredefinedAcl {
        ObjectsCopyDestinationPredefinedAcl::Undefined
    }
}

impl std::fmt::Display for ObjectsCopyDestinationPredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsCopyDestinationPredefinedAcl::Undefined => write!(f, "undefined"),
            ObjectsCopyDestinationPredefinedAcl::AuthenticatedRead => {
                write!(f, "authenticatedRead")
            }
            ObjectsCopyDestinationPredefinedAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            ObjectsCopyDestinationPredefinedAcl::BucketOwnerRead => write!(f, "bucketOwnerRead"),
            ObjectsCopyDestinationPredefinedAcl::Private => write!(f, "private"),
            ObjectsCopyDestinationPredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            ObjectsCopyDestinationPredefinedAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsCopyProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsCopyProjection {
    fn default() -> ObjectsCopyProjection {
        ObjectsCopyProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsCopyProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsCopyProjection::Undefined => write!(f, "undefined"),
            ObjectsCopyProjection::Full => write!(f, "full"),
            ObjectsCopyProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsGetProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsGetProjection {
    fn default() -> ObjectsGetProjection {
        ObjectsGetProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsGetProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsGetProjection::Undefined => write!(f, "undefined"),
            ObjectsGetProjection::Full => write!(f, "full"),
            ObjectsGetProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsInsertPredefinedAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for ObjectsInsertPredefinedAcl {
    fn default() -> ObjectsInsertPredefinedAcl {
        ObjectsInsertPredefinedAcl::Undefined
    }
}

impl std::fmt::Display for ObjectsInsertPredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsInsertPredefinedAcl::Undefined => write!(f, "undefined"),
            ObjectsInsertPredefinedAcl::AuthenticatedRead => write!(f, "authenticatedRead"),
            ObjectsInsertPredefinedAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            ObjectsInsertPredefinedAcl::BucketOwnerRead => write!(f, "bucketOwnerRead"),
            ObjectsInsertPredefinedAcl::Private => write!(f, "private"),
            ObjectsInsertPredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            ObjectsInsertPredefinedAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsInsertProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsInsertProjection {
    fn default() -> ObjectsInsertProjection {
        ObjectsInsertProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsInsertProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsInsertProjection::Undefined => write!(f, "undefined"),
            ObjectsInsertProjection::Full => write!(f, "full"),
            ObjectsInsertProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsListProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsListProjection {
    fn default() -> ObjectsListProjection {
        ObjectsListProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsListProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsListProjection::Undefined => write!(f, "undefined"),
            ObjectsListProjection::Full => write!(f, "full"),
            ObjectsListProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsPatchPredefinedAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for ObjectsPatchPredefinedAcl {
    fn default() -> ObjectsPatchPredefinedAcl {
        ObjectsPatchPredefinedAcl::Undefined
    }
}

impl std::fmt::Display for ObjectsPatchPredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsPatchPredefinedAcl::Undefined => write!(f, "undefined"),
            ObjectsPatchPredefinedAcl::AuthenticatedRead => write!(f, "authenticatedRead"),
            ObjectsPatchPredefinedAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            ObjectsPatchPredefinedAcl::BucketOwnerRead => write!(f, "bucketOwnerRead"),
            ObjectsPatchPredefinedAcl::Private => write!(f, "private"),
            ObjectsPatchPredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            ObjectsPatchPredefinedAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsPatchProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsPatchProjection {
    fn default() -> ObjectsPatchProjection {
        ObjectsPatchProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsPatchProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsPatchProjection::Undefined => write!(f, "undefined"),
            ObjectsPatchProjection::Full => write!(f, "full"),
            ObjectsPatchProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsRewriteDestinationPredefinedAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for ObjectsRewriteDestinationPredefinedAcl {
    fn default() -> ObjectsRewriteDestinationPredefinedAcl {
        ObjectsRewriteDestinationPredefinedAcl::Undefined
    }
}

impl std::fmt::Display for ObjectsRewriteDestinationPredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsRewriteDestinationPredefinedAcl::Undefined => write!(f, "undefined"),
            ObjectsRewriteDestinationPredefinedAcl::AuthenticatedRead => {
                write!(f, "authenticatedRead")
            }
            ObjectsRewriteDestinationPredefinedAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            ObjectsRewriteDestinationPredefinedAcl::BucketOwnerRead => write!(f, "bucketOwnerRead"),
            ObjectsRewriteDestinationPredefinedAcl::Private => write!(f, "private"),
            ObjectsRewriteDestinationPredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            ObjectsRewriteDestinationPredefinedAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsRewriteProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsRewriteProjection {
    fn default() -> ObjectsRewriteProjection {
        ObjectsRewriteProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsRewriteProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsRewriteProjection::Undefined => write!(f, "undefined"),
            ObjectsRewriteProjection::Full => write!(f, "full"),
            ObjectsRewriteProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsUpdatePredefinedAcl {
    Undefined,
    /// Object owner gets OWNER access, and allAuthenticatedUsers get READER
    /// access.
    #[serde(rename = "authenticatedRead")]
    AuthenticatedRead,
    /// Object owner gets OWNER access, and project team owners get OWNER
    /// access.
    #[serde(rename = "bucketOwnerFullControl")]
    BucketOwnerFullControl,
    /// Object owner gets OWNER access, and project team owners get READER
    /// access.
    #[serde(rename = "bucketOwnerRead")]
    BucketOwnerRead,
    /// Object owner gets OWNER access.
    #[serde(rename = "private")]
    Private,
    /// Object owner gets OWNER access, and project team members get access
    /// according to their roles.
    #[serde(rename = "projectPrivate")]
    ProjectPrivate,
    /// Object owner gets OWNER access, and allUsers get READER access.
    #[serde(rename = "publicRead")]
    PublicRead,
}

impl std::default::Default for ObjectsUpdatePredefinedAcl {
    fn default() -> ObjectsUpdatePredefinedAcl {
        ObjectsUpdatePredefinedAcl::Undefined
    }
}

impl std::fmt::Display for ObjectsUpdatePredefinedAcl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsUpdatePredefinedAcl::Undefined => write!(f, "undefined"),
            ObjectsUpdatePredefinedAcl::AuthenticatedRead => write!(f, "authenticatedRead"),
            ObjectsUpdatePredefinedAcl::BucketOwnerFullControl => {
                write!(f, "bucketOwnerFullControl")
            }
            ObjectsUpdatePredefinedAcl::BucketOwnerRead => write!(f, "bucketOwnerRead"),
            ObjectsUpdatePredefinedAcl::Private => write!(f, "private"),
            ObjectsUpdatePredefinedAcl::ProjectPrivate => write!(f, "projectPrivate"),
            ObjectsUpdatePredefinedAcl::PublicRead => write!(f, "publicRead"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsUpdateProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsUpdateProjection {
    fn default() -> ObjectsUpdateProjection {
        ObjectsUpdateProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsUpdateProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsUpdateProjection::Undefined => write!(f, "undefined"),
            ObjectsUpdateProjection::Full => write!(f, "full"),
            ObjectsUpdateProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ObjectsWatchAllProjection {
    Undefined,
    /// Include all properties.
    #[serde(rename = "full")]
    Full,
    /// Omit the owner, acl property.
    #[serde(rename = "noAcl")]
    NoAcl,
}

impl std::default::Default for ObjectsWatchAllProjection {
    fn default() -> ObjectsWatchAllProjection {
        ObjectsWatchAllProjection::Undefined
    }
}

impl std::fmt::Display for ObjectsWatchAllProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ObjectsWatchAllProjection::Undefined => write!(f, "undefined"),
            ObjectsWatchAllProjection::Full => write!(f, "full"),
            ObjectsWatchAllProjection::NoAcl => write!(f, "noAcl"),
        };
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum StorageParamsAlt {
    Undefined,
    /// Responses with Content-Type of application/json
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "media")]
    Media,
}

impl std::default::Default for StorageParamsAlt {
    fn default() -> StorageParamsAlt {
        StorageParamsAlt::Undefined
    }
}

impl std::fmt::Display for StorageParamsAlt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            StorageParamsAlt::Undefined => write!(f, "undefined"),
            StorageParamsAlt::Json => write!(f, "json"),
            StorageParamsAlt::Media => write!(f, "media"),
        };
        Ok(())
    }
}

/// Parameters for the `bucketAccessControls.delete` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControlsDeleteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketAccessControlsDeleteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `bucketAccessControls.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControlsGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketAccessControlsGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `bucketAccessControls.insert` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControlsInsertParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketAccessControlsInsertParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `bucketAccessControls.list` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControlsListParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketAccessControlsListParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `bucketAccessControls.patch` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControlsPatchParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketAccessControlsPatchParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `bucketAccessControls.update` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketAccessControlsUpdateParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketAccessControlsUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.delete` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsDeleteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If set, only deletes the bucket if its metageneration matches this
    /// value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: If set, only deletes the bucket if its metageneration does not
    /// match this value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsDeleteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: Makes the return of the bucket metadata conditional on whether the
    /// bucket's current metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the return of the bucket metadata conditional on whether the
    /// bucket's current metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Set of properties to return. Defaults to noAcl.
    #[serde(rename = "projection")]
    pub projection: Option<BucketsGetProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.getIamPolicy` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsGetIamPolicyParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The IAM policy format version to be returned. If the
    /// optionsRequestedPolicyVersion is for an older version that doesn't
    /// support part of the requested IAM policy, the request fails.
    #[serde(rename = "optionsRequestedPolicyVersion")]
    pub options_requested_policy_version: Option<i32>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsGetIamPolicyParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.options_requested_policy_version {
            write!(
                f,
                "&optionsRequestedPolicyVersion={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.insert` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsInsertParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Apply a predefined set of access controls to this bucket.
    #[serde(rename = "predefinedAcl")]
    pub predefined_acl: Option<BucketsInsertPredefinedAcl>,
    /// Apply a predefined set of default object access controls to this bucket.
    #[serde(rename = "predefinedDefaultObjectAcl")]
    pub predefined_default_object_acl: Option<BucketsInsertPredefinedDefaultObjectAcl>,
    /// A valid API project identifier.
    #[serde(rename = "project")]
    pub project: String,
    /// Set of properties to return. Defaults to noAcl, unless the bucket
    /// resource specifies acl or defaultObjectAcl properties, when it defaults
    /// to full.
    #[serde(rename = "projection")]
    pub projection: Option<BucketsInsertProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsInsertParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "&project={}",
            percent_encode(format!("{}", self.project).as_bytes(), NON_ALPHANUMERIC).to_string()
        )?;
        if let Some(ref v) = self.predefined_acl {
            write!(
                f,
                "&predefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_default_object_acl {
            write!(
                f,
                "&predefinedDefaultObjectAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.list` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsListParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Maximum number of buckets to return in a single response. The service
    /// will use this parameter or 1,000 items, whichever is smaller.
    #[serde(rename = "maxResults")]
    pub max_results: Option<u32>,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(rename = "pageToken")]
    pub page_token: Option<String>,
    /// Filter results to buckets whose names begin with this prefix.
    #[serde(rename = "prefix")]
    pub prefix: Option<String>,
    /// A valid API project identifier.
    #[serde(rename = "project")]
    pub project: String,
    /// Set of properties to return. Defaults to noAcl.
    #[serde(rename = "projection")]
    pub projection: Option<BucketsListProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsListParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "&project={}",
            percent_encode(format!("{}", self.project).as_bytes(), NON_ALPHANUMERIC).to_string()
        )?;
        if let Some(ref v) = self.max_results {
            write!(
                f,
                "&maxResults={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.page_token {
            write!(
                f,
                "&pageToken={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.prefix {
            write!(
                f,
                "&prefix={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.lockRetentionPolicy` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsLockRetentionPolicyParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: Makes the operation conditional on whether bucket's current
    /// metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsLockRetentionPolicyParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "&ifMetagenerationMatch={}",
            percent_encode(
                format!("{}", self.if_metageneration_match).as_bytes(),
                NON_ALPHANUMERIC
            )
            .to_string()
        )?;
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.patch` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsPatchParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: Makes the return of the bucket metadata conditional on whether the
    /// bucket's current metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the return of the bucket metadata conditional on whether the
    /// bucket's current metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Apply a predefined set of access controls to this bucket.
    #[serde(rename = "predefinedAcl")]
    pub predefined_acl: Option<BucketsPatchPredefinedAcl>,
    /// Apply a predefined set of default object access controls to this bucket.
    #[serde(rename = "predefinedDefaultObjectAcl")]
    pub predefined_default_object_acl: Option<BucketsPatchPredefinedDefaultObjectAcl>,
    /// Set of properties to return. Defaults to full.
    #[serde(rename = "projection")]
    pub projection: Option<BucketsPatchProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsPatchParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_acl {
            write!(
                f,
                "&predefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_default_object_acl {
            write!(
                f,
                "&predefinedDefaultObjectAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.setIamPolicy` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsSetIamPolicyParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsSetIamPolicyParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.testIamPermissions` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsTestIamPermissionsParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// Permissions to test.
    #[serde(rename = "permissions")]
    pub permissions: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsTestIamPermissionsParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "&permissions={}",
            percent_encode(format!("{}", self.permissions).as_bytes(), NON_ALPHANUMERIC)
                .to_string()
        )?;
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `buckets.update` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct BucketsUpdateParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: Makes the return of the bucket metadata conditional on whether the
    /// bucket's current metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the return of the bucket metadata conditional on whether the
    /// bucket's current metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Apply a predefined set of access controls to this bucket.
    #[serde(rename = "predefinedAcl")]
    pub predefined_acl: Option<BucketsUpdatePredefinedAcl>,
    /// Apply a predefined set of default object access controls to this bucket.
    #[serde(rename = "predefinedDefaultObjectAcl")]
    pub predefined_default_object_acl: Option<BucketsUpdatePredefinedDefaultObjectAcl>,
    /// Set of properties to return. Defaults to full.
    #[serde(rename = "projection")]
    pub projection: Option<BucketsUpdateProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for BucketsUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_acl {
            write!(
                f,
                "&predefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_default_object_acl {
            write!(
                f,
                "&predefinedDefaultObjectAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `channels.stop` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ChannelsStopParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
}

impl std::fmt::Display for ChannelsStopParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Ok(())
    }
}

/// Parameters for the `defaultObjectAccessControls.delete` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct DefaultObjectAccessControlsDeleteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for DefaultObjectAccessControlsDeleteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `defaultObjectAccessControls.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct DefaultObjectAccessControlsGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for DefaultObjectAccessControlsGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `defaultObjectAccessControls.insert` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct DefaultObjectAccessControlsInsertParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for DefaultObjectAccessControlsInsertParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `defaultObjectAccessControls.list` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct DefaultObjectAccessControlsListParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, only return default ACL listing if the bucket's current
    /// metageneration matches this value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: If present, only return default ACL listing if the bucket's current
    /// metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for DefaultObjectAccessControlsListParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `defaultObjectAccessControls.patch` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct DefaultObjectAccessControlsPatchParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for DefaultObjectAccessControlsPatchParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `defaultObjectAccessControls.update` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct DefaultObjectAccessControlsUpdateParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for DefaultObjectAccessControlsUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `notifications.delete` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct NotificationsDeleteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// The parent bucket of the notification.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// ID of the notification to delete.
    #[serde(rename = "notification")]
    pub notification: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for NotificationsDeleteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `notifications.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct NotificationsGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// The parent bucket of the notification.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// Notification ID
    #[serde(rename = "notification")]
    pub notification: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for NotificationsGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `notifications.insert` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct NotificationsInsertParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// The parent bucket of the notification.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for NotificationsInsertParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `notifications.list` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct NotificationsListParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a Google Cloud Storage bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for NotificationsListParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objectAccessControls.delete` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControlsDeleteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectAccessControlsDeleteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objectAccessControls.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControlsGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectAccessControlsGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objectAccessControls.insert` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControlsInsertParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectAccessControlsInsertParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objectAccessControls.list` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControlsListParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectAccessControlsListParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objectAccessControls.patch` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControlsPatchParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectAccessControlsPatchParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objectAccessControls.update` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectAccessControlsUpdateParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of a bucket.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// The entity holding the permission. Can be user-userId,
    /// user-emailAddress, group-groupId, group-emailAddress, allUsers, or
    /// allAuthenticatedUsers.
    #[serde(rename = "entity")]
    pub entity: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectAccessControlsUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.compose` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsComposeParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket containing the source objects. The destination object
    /// is stored in this bucket.
    #[serde(rename = "destinationBucket")]
    pub destination_bucket: String,
    /// Name of the new object. For information about how to URL encode object
    /// names to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "destinationObject")]
    pub destination_object: String,
    /// Apply a predefined set of access controls to the destination object.
    #[serde(rename = "destinationPredefinedAcl")]
    pub destination_predefined_acl: Option<ObjectsComposeDestinationPredefinedAcl>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// Resource name of the Cloud KMS key, of the form
    /// projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key,
    /// that will be used to encrypt the object. Overrides the object metadata's
    /// kms_key_name value, if any.
    #[serde(rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsComposeParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.destination_predefined_acl {
            write!(
                f,
                "&destinationPredefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.kms_key_name {
            write!(
                f,
                "&kmsKeyName={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.copy` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsCopyParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which to store the new object. Overrides the
    /// provided object metadata's bucket value, if any.For information about
    /// how to URL encode object names to be path safe, see Encoding URI Path
    /// Parts.
    #[serde(rename = "destinationBucket")]
    pub destination_bucket: String,
    /// Resource name of the Cloud KMS key, of the form
    /// projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key,
    /// that will be used to encrypt the object. Overrides the object metadata's
    /// kms_key_name value, if any.
    #[serde(rename = "destinationKmsKeyName")]
    pub destination_kms_key_name: Option<String>,
    /// Name of the new object. Required when the object metadata is not
    /// otherwise provided. Overrides the object metadata's name value, if any.
    #[serde(rename = "destinationObject")]
    pub destination_object: String,
    /// Apply a predefined set of access controls to the destination object.
    #[serde(rename = "destinationPredefinedAcl")]
    pub destination_predefined_acl: Option<ObjectsCopyDestinationPredefinedAcl>,
    /// i64: Makes the operation conditional on whether the destination object's
    /// current generation matches the given value. Setting to 0 makes the
    /// operation succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the destination object's
    /// current generation does not match the given value. If no live object
    /// exists, the precondition fails. Setting to 0 makes the operation succeed
    /// only if there is a live version of the object.
    #[serde(rename = "ifGenerationNotMatch")]
    pub if_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the destination object's
    /// current metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the destination object's
    /// current metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current generation matches the given value.
    #[serde(rename = "ifSourceGenerationMatch")]
    pub if_source_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current generation does not match the given value.
    #[serde(rename = "ifSourceGenerationNotMatch")]
    pub if_source_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current metageneration matches the given value.
    #[serde(rename = "ifSourceMetagenerationMatch")]
    pub if_source_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current metageneration does not match the given value.
    #[serde(rename = "ifSourceMetagenerationNotMatch")]
    pub if_source_metageneration_not_match: Option<String>,
    /// Set of properties to return. Defaults to noAcl, unless the object
    /// resource specifies the acl property, when it defaults to full.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsCopyProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// Name of the bucket in which to find the source object.
    #[serde(rename = "sourceBucket")]
    pub source_bucket: String,
    /// i64: If present, selects a specific revision of the source object (as
    /// opposed to the latest version, the default).
    #[serde(rename = "sourceGeneration")]
    pub source_generation: Option<String>,
    /// Name of the source object. For information about how to URL encode
    /// object names to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "sourceObject")]
    pub source_object: String,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsCopyParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.destination_kms_key_name {
            write!(
                f,
                "&destinationKmsKeyName={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.destination_predefined_acl {
            write!(
                f,
                "&destinationPredefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_not_match {
            write!(
                f,
                "&ifGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_generation_match {
            write!(
                f,
                "&ifSourceGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_generation_not_match {
            write!(
                f,
                "&ifSourceGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_metageneration_match {
            write!(
                f,
                "&ifSourceMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_metageneration_not_match {
            write!(
                f,
                "&ifSourceMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.source_generation {
            write!(
                f,
                "&sourceGeneration={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.delete` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsDeleteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which the object resides.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, permanently deletes a specific revision of this object
    /// (as opposed to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    #[serde(rename = "ifGenerationNotMatch")]
    pub if_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsDeleteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_not_match {
            write!(
                f,
                "&ifGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which the object resides.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    #[serde(rename = "ifGenerationNotMatch")]
    pub if_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// Set of properties to return. Defaults to noAcl.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsGetProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_not_match {
            write!(
                f,
                "&ifGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.getIamPolicy` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsGetIamPolicyParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which the object resides.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsGetIamPolicyParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.insert` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsInsertParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which to store the new object. Overrides the
    /// provided object metadata's bucket value, if any.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// If set, sets the contentEncoding property of the final object to this
    /// value. Setting this parameter is equivalent to setting the
    /// contentEncoding metadata property. This can be useful when uploading an
    /// object with uploadType=media to indicate the encoding of the content
    /// being uploaded.
    #[serde(rename = "contentEncoding")]
    pub content_encoding: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    #[serde(rename = "ifGenerationNotMatch")]
    pub if_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Resource name of the Cloud KMS key, of the form
    /// projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key,
    /// that will be used to encrypt the object. Overrides the object metadata's
    /// kms_key_name value, if any.
    #[serde(rename = "kmsKeyName")]
    pub kms_key_name: Option<String>,
    /// Name of the object. Required when the object metadata is not otherwise
    /// provided. Overrides the object metadata's name value, if any. For
    /// information about how to URL encode object names to be path safe, see
    /// Encoding URI Path Parts.
    #[serde(rename = "name")]
    pub name: Option<String>,
    /// Apply a predefined set of access controls to this object.
    #[serde(rename = "predefinedAcl")]
    pub predefined_acl: Option<ObjectsInsertPredefinedAcl>,
    /// Set of properties to return. Defaults to noAcl, unless the object
    /// resource specifies the acl property, when it defaults to full.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsInsertProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsInsertParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.content_encoding {
            write!(
                f,
                "&contentEncoding={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_not_match {
            write!(
                f,
                "&ifGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.kms_key_name {
            write!(
                f,
                "&kmsKeyName={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.name {
            write!(
                f,
                "&name={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_acl {
            write!(
                f,
                "&predefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.list` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsListParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which to look for objects.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// Returns results in a directory-like mode. items will contain only
    /// objects whose names, aside from the prefix, do not contain delimiter.
    /// Objects whose names, aside from the prefix, contain delimiter will have
    /// their name, truncated after the delimiter, returned in prefixes.
    /// Duplicate prefixes are omitted.
    #[serde(rename = "delimiter")]
    pub delimiter: Option<String>,
    /// Filter results to objects whose names are lexicographically before
    /// endOffset. If startOffset is also set, the objects listed will have
    /// names between startOffset (inclusive) and endOffset (exclusive).
    #[serde(rename = "endOffset")]
    pub end_offset: Option<String>,
    /// If true, objects that end in exactly one instance of delimiter will have
    /// their metadata included in items in addition to prefixes.
    #[serde(rename = "includeTrailingDelimiter")]
    pub include_trailing_delimiter: Option<bool>,
    /// Maximum number of items plus prefixes to return in a single page of
    /// responses. As duplicate prefixes are omitted, fewer total results may be
    /// returned than requested. The service will use this parameter or 1,000
    /// items, whichever is smaller.
    #[serde(rename = "maxResults")]
    pub max_results: Option<u32>,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(rename = "pageToken")]
    pub page_token: Option<String>,
    /// Filter results to objects whose names begin with this prefix.
    #[serde(rename = "prefix")]
    pub prefix: Option<String>,
    /// Set of properties to return. Defaults to noAcl.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsListProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// Filter results to objects whose names are lexicographically equal to or
    /// after startOffset. If endOffset is also set, the objects listed will
    /// have names between startOffset (inclusive) and endOffset (exclusive).
    #[serde(rename = "startOffset")]
    pub start_offset: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
    /// If true, lists all versions of an object as distinct results. The
    /// default is false. For more information, see Object Versioning.
    #[serde(rename = "versions")]
    pub versions: Option<bool>,
}

impl std::fmt::Display for ObjectsListParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.delimiter {
            write!(
                f,
                "&delimiter={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.end_offset {
            write!(
                f,
                "&endOffset={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.include_trailing_delimiter {
            write!(
                f,
                "&includeTrailingDelimiter={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.max_results {
            write!(
                f,
                "&maxResults={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.page_token {
            write!(
                f,
                "&pageToken={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.prefix {
            write!(
                f,
                "&prefix={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.start_offset {
            write!(
                f,
                "&startOffset={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.versions {
            write!(
                f,
                "&versions={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.patch` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsPatchParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which the object resides.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    #[serde(rename = "ifGenerationNotMatch")]
    pub if_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// Apply a predefined set of access controls to this object.
    #[serde(rename = "predefinedAcl")]
    pub predefined_acl: Option<ObjectsPatchPredefinedAcl>,
    /// Set of properties to return. Defaults to full.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsPatchProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request, for Requester Pays buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsPatchParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_not_match {
            write!(
                f,
                "&ifGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_acl {
            write!(
                f,
                "&predefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.rewrite` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsRewriteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which to store the new object. Overrides the
    /// provided object metadata's bucket value, if any.
    #[serde(rename = "destinationBucket")]
    pub destination_bucket: String,
    /// Resource name of the Cloud KMS key, of the form
    /// projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key,
    /// that will be used to encrypt the object. Overrides the object metadata's
    /// kms_key_name value, if any.
    #[serde(rename = "destinationKmsKeyName")]
    pub destination_kms_key_name: Option<String>,
    /// Name of the new object. Required when the object metadata is not
    /// otherwise provided. Overrides the object metadata's name value, if any.
    /// For information about how to URL encode object names to be path safe,
    /// see Encoding URI Path Parts.
    #[serde(rename = "destinationObject")]
    pub destination_object: String,
    /// Apply a predefined set of access controls to the destination object.
    #[serde(rename = "destinationPredefinedAcl")]
    pub destination_predefined_acl: Option<ObjectsRewriteDestinationPredefinedAcl>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    #[serde(rename = "ifGenerationNotMatch")]
    pub if_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the destination object's
    /// current metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the destination object's
    /// current metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current generation matches the given value.
    #[serde(rename = "ifSourceGenerationMatch")]
    pub if_source_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current generation does not match the given value.
    #[serde(rename = "ifSourceGenerationNotMatch")]
    pub if_source_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current metageneration matches the given value.
    #[serde(rename = "ifSourceMetagenerationMatch")]
    pub if_source_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the source object's
    /// current metageneration does not match the given value.
    #[serde(rename = "ifSourceMetagenerationNotMatch")]
    pub if_source_metageneration_not_match: Option<String>,
    /// i64: The maximum number of bytes that will be rewritten per rewrite
    /// request. Most callers shouldn't need to specify this parameter - it is
    /// primarily in place to support testing. If specified the value must be an
    /// integral multiple of 1 MiB (1048576). Also, this only applies to
    /// requests where the source and destination span locations and/or storage
    /// classes. Finally, this value must not change across rewrite calls else
    /// you'll get an error that the rewriteToken is invalid.
    #[serde(rename = "maxBytesRewrittenPerCall")]
    pub max_bytes_rewritten_per_call: Option<String>,
    /// Set of properties to return. Defaults to noAcl, unless the object
    /// resource specifies the acl property, when it defaults to full.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsRewriteProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// Include this field (from the previous rewrite response) on each rewrite
    /// request after the first one, until the rewrite response 'done' flag is
    /// true. Calls that provide a rewriteToken can omit all other request
    /// fields, but if included those fields must match the values provided in
    /// the first rewrite request.
    #[serde(rename = "rewriteToken")]
    pub rewrite_token: Option<String>,
    /// Name of the bucket in which to find the source object.
    #[serde(rename = "sourceBucket")]
    pub source_bucket: String,
    /// i64: If present, selects a specific revision of the source object (as
    /// opposed to the latest version, the default).
    #[serde(rename = "sourceGeneration")]
    pub source_generation: Option<String>,
    /// Name of the source object. For information about how to URL encode
    /// object names to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "sourceObject")]
    pub source_object: String,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsRewriteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.destination_kms_key_name {
            write!(
                f,
                "&destinationKmsKeyName={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.destination_predefined_acl {
            write!(
                f,
                "&destinationPredefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_not_match {
            write!(
                f,
                "&ifGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_generation_match {
            write!(
                f,
                "&ifSourceGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_generation_not_match {
            write!(
                f,
                "&ifSourceGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_metageneration_match {
            write!(
                f,
                "&ifSourceMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_source_metageneration_not_match {
            write!(
                f,
                "&ifSourceMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.max_bytes_rewritten_per_call {
            write!(
                f,
                "&maxBytesRewrittenPerCall={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.rewrite_token {
            write!(
                f,
                "&rewriteToken={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.source_generation {
            write!(
                f,
                "&sourceGeneration={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.setIamPolicy` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsSetIamPolicyParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which the object resides.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsSetIamPolicyParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.testIamPermissions` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsTestIamPermissionsParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which the object resides.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// Permissions to test.
    #[serde(rename = "permissions")]
    pub permissions: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsTestIamPermissionsParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "&permissions={}",
            percent_encode(format!("{}", self.permissions).as_bytes(), NON_ALPHANUMERIC)
                .to_string()
        )?;
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.update` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsUpdateParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which the object resides.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// i64: If present, selects a specific revision of this object (as opposed
    /// to the latest version, the default).
    #[serde(rename = "generation")]
    pub generation: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation matches the given value. Setting to 0 makes the operation
    /// succeed only if there are no live versions of the object.
    #[serde(rename = "ifGenerationMatch")]
    pub if_generation_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// generation does not match the given value. If no live object exists, the
    /// precondition fails. Setting to 0 makes the operation succeed only if
    /// there is a live version of the object.
    #[serde(rename = "ifGenerationNotMatch")]
    pub if_generation_not_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration matches the given value.
    #[serde(rename = "ifMetagenerationMatch")]
    pub if_metageneration_match: Option<String>,
    /// i64: Makes the operation conditional on whether the object's current
    /// metageneration does not match the given value.
    #[serde(rename = "ifMetagenerationNotMatch")]
    pub if_metageneration_not_match: Option<String>,
    /// Name of the object. For information about how to URL encode object names
    /// to be path safe, see Encoding URI Path Parts.
    #[serde(rename = "object")]
    pub object: String,
    /// Apply a predefined set of access controls to this object.
    #[serde(rename = "predefinedAcl")]
    pub predefined_acl: Option<ObjectsUpdatePredefinedAcl>,
    /// Set of properties to return. Defaults to full.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsUpdateProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ObjectsUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.generation {
            write!(
                f,
                "&generation={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_match {
            write!(
                f,
                "&ifGenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_generation_not_match {
            write!(
                f,
                "&ifGenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_match {
            write!(
                f,
                "&ifMetagenerationMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.if_metageneration_not_match {
            write!(
                f,
                "&ifMetagenerationNotMatch={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.predefined_acl {
            write!(
                f,
                "&predefinedAcl={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `objects.watchAll` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ObjectsWatchAllParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the bucket in which to look for objects.
    #[serde(rename = "bucket")]
    pub bucket: String,
    /// Returns results in a directory-like mode. items will contain only
    /// objects whose names, aside from the prefix, do not contain delimiter.
    /// Objects whose names, aside from the prefix, contain delimiter will have
    /// their name, truncated after the delimiter, returned in prefixes.
    /// Duplicate prefixes are omitted.
    #[serde(rename = "delimiter")]
    pub delimiter: Option<String>,
    /// Filter results to objects whose names are lexicographically before
    /// endOffset. If startOffset is also set, the objects listed will have
    /// names between startOffset (inclusive) and endOffset (exclusive).
    #[serde(rename = "endOffset")]
    pub end_offset: Option<String>,
    /// If true, objects that end in exactly one instance of delimiter will have
    /// their metadata included in items in addition to prefixes.
    #[serde(rename = "includeTrailingDelimiter")]
    pub include_trailing_delimiter: Option<bool>,
    /// Maximum number of items plus prefixes to return in a single page of
    /// responses. As duplicate prefixes are omitted, fewer total results may be
    /// returned than requested. The service will use this parameter or 1,000
    /// items, whichever is smaller.
    #[serde(rename = "maxResults")]
    pub max_results: Option<u32>,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(rename = "pageToken")]
    pub page_token: Option<String>,
    /// Filter results to objects whose names begin with this prefix.
    #[serde(rename = "prefix")]
    pub prefix: Option<String>,
    /// Set of properties to return. Defaults to noAcl.
    #[serde(rename = "projection")]
    pub projection: Option<ObjectsWatchAllProjection>,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// Filter results to objects whose names are lexicographically equal to or
    /// after startOffset. If endOffset is also set, the objects listed will
    /// have names between startOffset (inclusive) and endOffset (exclusive).
    #[serde(rename = "startOffset")]
    pub start_offset: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays
    /// buckets.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
    /// If true, lists all versions of an object as distinct results. The
    /// default is false. For more information, see Object Versioning.
    #[serde(rename = "versions")]
    pub versions: Option<bool>,
}

impl std::fmt::Display for ObjectsWatchAllParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.delimiter {
            write!(
                f,
                "&delimiter={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.end_offset {
            write!(
                f,
                "&endOffset={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.include_trailing_delimiter {
            write!(
                f,
                "&includeTrailingDelimiter={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.max_results {
            write!(
                f,
                "&maxResults={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.page_token {
            write!(
                f,
                "&pageToken={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.prefix {
            write!(
                f,
                "&prefix={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.projection {
            write!(
                f,
                "&projection={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.start_offset {
            write!(
                f,
                "&startOffset={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.versions {
            write!(
                f,
                "&versions={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `hmacKeys.create` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ProjectsHmacKeysCreateParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Project ID owning the service account.
    #[serde(rename = "projectId")]
    pub project_id: String,
    /// Email address of the service account.
    #[serde(rename = "serviceAccountEmail")]
    pub service_account_email: String,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ProjectsHmacKeysCreateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "&serviceAccountEmail={}",
            percent_encode(
                format!("{}", self.service_account_email).as_bytes(),
                NON_ALPHANUMERIC
            )
            .to_string()
        )?;
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `hmacKeys.delete` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ProjectsHmacKeysDeleteParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the HMAC key to be deleted.
    #[serde(rename = "accessId")]
    pub access_id: String,
    /// Project ID owning the requested key
    #[serde(rename = "projectId")]
    pub project_id: String,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ProjectsHmacKeysDeleteParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `hmacKeys.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ProjectsHmacKeysGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the HMAC key.
    #[serde(rename = "accessId")]
    pub access_id: String,
    /// Project ID owning the service account of the requested key.
    #[serde(rename = "projectId")]
    pub project_id: String,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ProjectsHmacKeysGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `hmacKeys.list` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ProjectsHmacKeysListParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Maximum number of items to return in a single page of responses. The
    /// service uses this parameter or 250 items, whichever is smaller. The max
    /// number of items per page will also be limited by the number of distinct
    /// service accounts in the response. If the number of service accounts in a
    /// single response is too high, the page will truncated and a next page
    /// token will be returned.
    #[serde(rename = "maxResults")]
    pub max_results: Option<u32>,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[serde(rename = "pageToken")]
    pub page_token: Option<String>,
    /// Name of the project in which to look for HMAC keys.
    #[serde(rename = "projectId")]
    pub project_id: String,
    /// If present, only keys for the given service account are returned.
    #[serde(rename = "serviceAccountEmail")]
    pub service_account_email: Option<String>,
    /// Whether or not to show keys in the DELETED state.
    #[serde(rename = "showDeletedKeys")]
    pub show_deleted_keys: Option<bool>,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ProjectsHmacKeysListParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.max_results {
            write!(
                f,
                "&maxResults={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.page_token {
            write!(
                f,
                "&pageToken={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.service_account_email {
            write!(
                f,
                "&serviceAccountEmail={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.show_deleted_keys {
            write!(
                f,
                "&showDeletedKeys={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `hmacKeys.update` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ProjectsHmacKeysUpdateParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Name of the HMAC key being updated.
    #[serde(rename = "accessId")]
    pub access_id: String,
    /// Project ID owning the service account of the updated key.
    #[serde(rename = "projectId")]
    pub project_id: String,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ProjectsHmacKeysUpdateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// Parameters for the `serviceAccount.get` method.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ProjectsServiceAccountGetParams {
    /// General attributes applying to any API call
    #[serde(flatten)]
    pub storage_params: Option<StorageParams>,
    /// Project ID
    #[serde(rename = "projectId")]
    pub project_id: String,
    /// The project to be billed for this request if the target bucket is
    /// requester-pays bucket.
    #[serde(rename = "provisionalUserProject")]
    pub provisional_user_project: Option<String>,
    /// The project to be billed for this request.
    #[serde(rename = "userProject")]
    pub user_project: Option<String>,
}

impl std::fmt::Display for ProjectsServiceAccountGetParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.provisional_user_project {
            write!(
                f,
                "&provisionalUserProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_project {
            write!(
                f,
                "&userProject={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

///
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct StorageParams {
    /// Data format for the response.
    #[serde(rename = "alt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alt: Option<StorageParamsAlt>,
    /// Selector specifying which fields to include in a partial response.
    #[serde(rename = "fields")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API
    /// access, quota, and reports. Required unless you provide an OAuth 2.0
    /// token.
    #[serde(rename = "key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    #[serde(rename = "oauth_token")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    #[serde(rename = "prettyPrint")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not
    /// exceed 40 characters.
    #[serde(rename = "quotaUser")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quota_user: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    #[serde(rename = "userIp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_ip: Option<String>,
}

impl std::fmt::Display for StorageParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(ref v) = self.alt {
            write!(
                f,
                "&alt={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.fields {
            write!(
                f,
                "&fields={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.key {
            write!(
                f,
                "&key={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.oauth_token {
            write!(
                f,
                "&oauth_token={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.pretty_print {
            write!(
                f,
                "&prettyPrint={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.quota_user {
            write!(
                f,
                "&quotaUser={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        if let Some(ref v) = self.user_ip {
            write!(
                f,
                "&userIp={}",
                percent_encode(format!("{}", v).as_bytes(), NON_ALPHANUMERIC).to_string()
            )?;
        }
        Ok(())
    }
}

/// The Storage BucketAccessControls service represents the BucketAccessControls
/// resource.
pub struct BucketAccessControlsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl BucketAccessControlsService {
    /// Create a new BucketAccessControlsService object. The easiest way to call
    /// this is wrapping the Authenticator into an `Rc`:
    /// `new(client.clone(), Rc::new(authenticator))`. This way, one
    /// authenticator can be shared among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> BucketAccessControlsService {
        BucketAccessControlsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Permanently deletes the ACL entry for the specified entity on the
    /// specified bucket.
    pub async fn delete(&self, params: &BucketAccessControlsDeleteParams) -> Result<()> {
        let rel_path = format!(
            "b/{bucket}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "DELETE", opt_request).await
    }

    /// Returns the ACL entry for the specified entity on the specified bucket.
    pub async fn get(&self, params: &BucketAccessControlsGetParams) -> Result<BucketAccessControl> {
        let rel_path = format!(
            "b/{bucket}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Creates a new ACL entry on the specified bucket.
    pub async fn insert(
        &self,
        params: &BucketAccessControlsInsertParams,
        req: &BucketAccessControl,
    ) -> Result<BucketAccessControl> {
        let rel_path = format!(
            "b/{bucket}/acl",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Retrieves ACL entries on the specified bucket.
    pub async fn list(
        &self,
        params: &BucketAccessControlsListParams,
    ) -> Result<BucketAccessControls> {
        let rel_path = format!(
            "b/{bucket}/acl",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Patches an ACL entry on the specified bucket.
    pub async fn patch(
        &self,
        params: &BucketAccessControlsPatchParams,
        req: &BucketAccessControl,
    ) -> Result<BucketAccessControl> {
        let rel_path = format!(
            "b/{bucket}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PATCH", opt_request).await
    }

    /// Updates an ACL entry on the specified bucket.
    pub async fn update(
        &self,
        params: &BucketAccessControlsUpdateParams,
        req: &BucketAccessControl,
    ) -> Result<BucketAccessControl> {
        let rel_path = format!(
            "b/{bucket}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }
}

/// The Storage Buckets service represents the Buckets resource.
pub struct BucketsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl BucketsService {
    /// Create a new BucketsService object. The easiest way to call this is
    /// wrapping the Authenticator into an `Rc`: `new(client.clone(),
    /// Rc::new(authenticator))`. This way, one authenticator can be shared
    /// among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> BucketsService {
        BucketsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Permanently deletes an empty bucket.
    pub async fn delete(&self, params: &BucketsDeleteParams) -> Result<()> {
        let rel_path = format!(
            "b/{bucket}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "DELETE", opt_request).await
    }

    /// Returns metadata for the specified bucket.
    pub async fn get(&self, params: &BucketsGetParams) -> Result<Bucket> {
        let rel_path = format!(
            "b/{bucket}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Returns an IAM policy for the specified bucket.
    pub async fn get_iam_policy(&self, params: &BucketsGetIamPolicyParams) -> Result<Policy> {
        let rel_path = format!(
            "b/{bucket}/iam",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Creates a new bucket.
    pub async fn insert(&self, params: &BucketsInsertParams, req: &Bucket) -> Result<Bucket> {
        let rel_path = format!("b",);
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Retrieves a list of buckets for a given project.
    pub async fn list(&self, params: &BucketsListParams) -> Result<Buckets> {
        let rel_path = format!("b",);
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Locks retention policy on a bucket.
    pub async fn lock_retention_policy(
        &self,
        params: &BucketsLockRetentionPolicyParams,
    ) -> Result<Bucket> {
        let rel_path = format!(
            "b/{bucket}/lockRetentionPolicy",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Patches a bucket. Changes to the bucket will be readable immediately
    /// after writing, but configuration changes may take time to propagate.
    pub async fn patch(&self, params: &BucketsPatchParams, req: &Bucket) -> Result<Bucket> {
        let rel_path = format!(
            "b/{bucket}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PATCH", opt_request).await
    }

    /// Updates an IAM policy for the specified bucket.
    pub async fn set_iam_policy(
        &self,
        params: &BucketsSetIamPolicyParams,
        req: &Policy,
    ) -> Result<Policy> {
        let rel_path = format!(
            "b/{bucket}/iam",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }

    /// Tests a set of permissions on the given bucket to see which, if any, are
    /// held by the caller.
    pub async fn test_iam_permissions(
        &self,
        params: &BucketsTestIamPermissionsParams,
    ) -> Result<TestIamPermissionsResponse> {
        let rel_path = format!(
            "b/{bucket}/iam/testPermissions",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Updates a bucket. Changes to the bucket will be readable immediately
    /// after writing, but configuration changes may take time to propagate.
    pub async fn update(&self, params: &BucketsUpdateParams, req: &Bucket) -> Result<Bucket> {
        let rel_path = format!(
            "b/{bucket}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }
}

/// The Storage Channels service represents the Channels resource.
pub struct ChannelsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl ChannelsService {
    /// Create a new ChannelsService object. The easiest way to call this is
    /// wrapping the Authenticator into an `Rc`: `new(client.clone(),
    /// Rc::new(authenticator))`. This way, one authenticator can be shared
    /// among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> ChannelsService {
        ChannelsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Stop watching resources through this channel
    pub async fn stop(&self, params: &ChannelsStopParams, req: &Channel) -> Result<()> {
        let rel_path = format!("channels/stop",);
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }
}

/// The Storage DefaultObjectAccessControls service represents the
/// DefaultObjectAccessControls resource.
pub struct DefaultObjectAccessControlsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl DefaultObjectAccessControlsService {
    /// Create a new DefaultObjectAccessControlsService object. The easiest way
    /// to call this is wrapping the Authenticator into an `Rc`:
    /// `new(client.clone(), Rc::new(authenticator))`. This way, one
    /// authenticator can be shared among several services.
    pub fn new<A: 'static + DerefAuth>(
        client: TlsClient,
        auth: A,
    ) -> DefaultObjectAccessControlsService {
        DefaultObjectAccessControlsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Permanently deletes the default object ACL entry for the specified
    /// entity on the specified bucket.
    pub async fn delete(&self, params: &DefaultObjectAccessControlsDeleteParams) -> Result<()> {
        let rel_path = format!(
            "b/{bucket}/defaultObjectAcl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "DELETE", opt_request).await
    }

    /// Returns the default object ACL entry for the specified entity on the
    /// specified bucket.
    pub async fn get(
        &self,
        params: &DefaultObjectAccessControlsGetParams,
    ) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/defaultObjectAcl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Creates a new default object ACL entry on the specified bucket.
    pub async fn insert(
        &self,
        params: &DefaultObjectAccessControlsInsertParams,
        req: &ObjectAccessControl,
    ) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/defaultObjectAcl",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Retrieves default object ACL entries on the specified bucket.
    pub async fn list(
        &self,
        params: &DefaultObjectAccessControlsListParams,
    ) -> Result<ObjectAccessControls> {
        let rel_path = format!(
            "b/{bucket}/defaultObjectAcl",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Patches a default object ACL entry on the specified bucket.
    pub async fn patch(
        &self,
        params: &DefaultObjectAccessControlsPatchParams,
        req: &ObjectAccessControl,
    ) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/defaultObjectAcl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PATCH", opt_request).await
    }

    /// Updates a default object ACL entry on the specified bucket.
    pub async fn update(
        &self,
        params: &DefaultObjectAccessControlsUpdateParams,
        req: &ObjectAccessControl,
    ) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/defaultObjectAcl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }
}

/// The Storage Notifications service represents the Notifications resource.
pub struct NotificationsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl NotificationsService {
    /// Create a new NotificationsService object. The easiest way to call this
    /// is wrapping the Authenticator into an `Rc`: `new(client.clone(),
    /// Rc::new(authenticator))`. This way, one authenticator can be shared
    /// among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> NotificationsService {
        NotificationsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Permanently deletes a notification subscription.
    pub async fn delete(&self, params: &NotificationsDeleteParams) -> Result<()> {
        let rel_path = format!(
            "b/{bucket}/notificationConfigs/{notification}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            notification = percent_encode(
                format!("{}", params.notification).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "DELETE", opt_request).await
    }

    /// View a notification configuration.
    pub async fn get(&self, params: &NotificationsGetParams) -> Result<Notification> {
        let rel_path = format!(
            "b/{bucket}/notificationConfigs/{notification}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            notification = percent_encode(
                format!("{}", params.notification).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Creates a notification subscription for a given bucket.
    pub async fn insert(
        &self,
        params: &NotificationsInsertParams,
        req: &Notification,
    ) -> Result<Notification> {
        let rel_path = format!(
            "b/{bucket}/notificationConfigs",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Retrieves a list of notification subscriptions for a given bucket.
    pub async fn list(&self, params: &NotificationsListParams) -> Result<Notifications> {
        let rel_path = format!(
            "b/{bucket}/notificationConfigs",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }
}

/// The Storage ObjectAccessControls service represents the ObjectAccessControls
/// resource.
pub struct ObjectAccessControlsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl ObjectAccessControlsService {
    /// Create a new ObjectAccessControlsService object. The easiest way to call
    /// this is wrapping the Authenticator into an `Rc`:
    /// `new(client.clone(), Rc::new(authenticator))`. This way, one
    /// authenticator can be shared among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> ObjectAccessControlsService {
        ObjectAccessControlsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Permanently deletes the ACL entry for the specified entity on the
    /// specified object.
    pub async fn delete(&self, params: &ObjectAccessControlsDeleteParams) -> Result<()> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "DELETE", opt_request).await
    }

    /// Returns the ACL entry for the specified entity on the specified object.
    pub async fn get(&self, params: &ObjectAccessControlsGetParams) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Creates a new ACL entry on the specified object.
    pub async fn insert(
        &self,
        params: &ObjectAccessControlsInsertParams,
        req: &ObjectAccessControl,
    ) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/acl",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Retrieves ACL entries on the specified object.
    pub async fn list(
        &self,
        params: &ObjectAccessControlsListParams,
    ) -> Result<ObjectAccessControls> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/acl",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Patches an ACL entry on the specified object.
    pub async fn patch(
        &self,
        params: &ObjectAccessControlsPatchParams,
        req: &ObjectAccessControl,
    ) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PATCH", opt_request).await
    }

    /// Updates an ACL entry on the specified object.
    pub async fn update(
        &self,
        params: &ObjectAccessControlsUpdateParams,
        req: &ObjectAccessControl,
    ) -> Result<ObjectAccessControl> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/acl/{entity}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC),
            entity = percent_encode(format!("{}", params.entity).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }
}

/// The Storage Objects service represents the Objects resource.
pub struct ObjectsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl ObjectsService {
    /// Create a new ObjectsService object. The easiest way to call this is
    /// wrapping the Authenticator into an `Rc`: `new(client.clone(),
    /// Rc::new(authenticator))`. This way, one authenticator can be shared
    /// among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> ObjectsService {
        ObjectsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Concatenates a list of existing objects into a new object in the same
    /// bucket.
    pub async fn compose(
        &self,
        params: &ObjectsComposeParams,
        req: &ComposeRequest,
    ) -> Result<Object> {
        let rel_path = format!(
            "b/{destinationBucket}/o/{destinationObject}/compose",
            destinationBucket = percent_encode(
                format!("{}", params.destination_bucket).as_bytes(),
                NON_ALPHANUMERIC
            ),
            destinationObject = percent_encode(
                format!("{}", params.destination_object).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Copies a source object to a destination object. Optionally overrides
    /// metadata.
    pub async fn copy(&self, params: &ObjectsCopyParams, req: &Object) -> Result<Object> {
        let rel_path = format!(
            "b/{sourceBucket}/o/{sourceObject}/copyTo/b/{destinationBucket}/o/{destinationObject}",
            sourceBucket = percent_encode(
                format!("{}", params.source_bucket).as_bytes(),
                NON_ALPHANUMERIC
            ),
            sourceObject = percent_encode(
                format!("{}", params.source_object).as_bytes(),
                NON_ALPHANUMERIC
            ),
            destinationBucket = percent_encode(
                format!("{}", params.destination_bucket).as_bytes(),
                NON_ALPHANUMERIC
            ),
            destinationObject = percent_encode(
                format!("{}", params.destination_object).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Deletes an object and its metadata. Deletions are permanent if
    /// versioning is not enabled for the bucket, or if the generation parameter
    /// is used.
    pub async fn delete(&self, params: &ObjectsDeleteParams) -> Result<()> {
        let rel_path = format!(
            "b/{bucket}/o/{object}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "DELETE", opt_request).await
    }

    /// Retrieves an object or its metadata.
    ///
    /// This method potentially downloads data. See documentation of `Download`.
    pub async fn get<'a>(
        &'a self,
        params: &ObjectsGetParams,
    ) -> Result<Download<'a, EmptyRequest, Object>> {
        let rel_path = format!(
            "b/{bucket}/o/{object}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);
        let opt_request: Option<&EmptyRequest> = None;

        do_download(&self.client, &full_uri, headers, "GET".into(), opt_request).await
    }

    /// Returns an IAM policy for the specified object.
    pub async fn get_iam_policy(&self, params: &ObjectsGetIamPolicyParams) -> Result<Policy> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/iam",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Stores a new object and metadata.
    pub async fn insert(&self, params: &ObjectsInsertParams, req: &Object) -> Result<Object> {
        let rel_path = format!(
            "b/{bucket}/o",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Stores a new object and metadata.
    ///
    /// This method is a variant of `insert()`, taking data for upload. It
    /// performs a multipart upload.
    pub async fn insert_upload(
        &self,
        params: &ObjectsInsertParams,
        req: &Object,
        data: hyper::body::Bytes,
    ) -> Result<Object> {
        let rel_path = format!(
            "/upload/storage/v1/b/{bucket}/o",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?uploadType=multipart{params}", params = params);

        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);
        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);

        do_upload_multipart(&self.client, &full_uri, &headers, "POST", opt_request, data).await
    }

    /// Stores a new object and metadata.
    ///
    /// This method is a variant of `insert()`, taking data for upload.
    /// It returns a `ResumableUpload` upload manager which you can use to
    /// stream larger amounts of data to the API. The result of this call
    /// will be returned by the `ResumableUpload` method you choose for the
    /// upload.
    pub async fn insert_resumable_upload<'client>(
        &'client self,
        params: &ObjectsInsertParams,
        req: &Object,
    ) -> Result<ResumableUpload<'client, Object>> {
        let rel_path = format!(
            "/resumable/upload/storage/v1/b/{bucket}/o",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?uploadType=resumable{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        let (_resp, headers): (EmptyResponse, hyper::HeaderMap) =
            do_request_with_headers(&self.client, &full_uri, &headers, "POST", opt_request).await?;
        if let Some(dest) = headers.get(hyper::header::LOCATION) {
            use std::convert::TryFrom;
            Ok(ResumableUpload::new(
                hyper::Uri::try_from(dest.to_str()?)?,
                &self.client,
                5 * 1024 * 1024,
            ))
        } else {
            Err(Error::from(ApiError::RedirectError(format!(
                "Resumable upload response didn't contain Location: {:?}",
                headers
            )))
            .context(format!("{:?}", headers)))?
        }
    }

    /// Retrieves a list of objects matching the criteria.
    pub async fn list(&self, params: &ObjectsListParams) -> Result<Objects> {
        let rel_path = format!(
            "b/{bucket}/o",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Patches an object's metadata.
    pub async fn patch(&self, params: &ObjectsPatchParams, req: &Object) -> Result<Object> {
        let rel_path = format!(
            "b/{bucket}/o/{object}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PATCH", opt_request).await
    }

    /// Rewrites a source object to a destination object. Optionally overrides
    /// metadata.
    pub async fn rewrite(
        &self,
        params: &ObjectsRewriteParams,
        req: &Object,
    ) -> Result<RewriteResponse> {
        let rel_path = format!(
            "b/{sourceBucket}/o/{sourceObject}/rewriteTo/b/{destinationBucket}/o/\
             {destinationObject}",
            sourceBucket = percent_encode(
                format!("{}", params.source_bucket).as_bytes(),
                NON_ALPHANUMERIC
            ),
            sourceObject = percent_encode(
                format!("{}", params.source_object).as_bytes(),
                NON_ALPHANUMERIC
            ),
            destinationBucket = percent_encode(
                format!("{}", params.destination_bucket).as_bytes(),
                NON_ALPHANUMERIC
            ),
            destinationObject = percent_encode(
                format!("{}", params.destination_object).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Updates an IAM policy for the specified object.
    pub async fn set_iam_policy(
        &self,
        params: &ObjectsSetIamPolicyParams,
        req: &Policy,
    ) -> Result<Policy> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/iam",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }

    /// Tests a set of permissions on the given object to see which, if any, are
    /// held by the caller.
    pub async fn test_iam_permissions(
        &self,
        params: &ObjectsTestIamPermissionsParams,
    ) -> Result<TestIamPermissionsResponse> {
        let rel_path = format!(
            "b/{bucket}/o/{object}/iam/testPermissions",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Updates an object's metadata.
    pub async fn update(&self, params: &ObjectsUpdateParams, req: &Object) -> Result<Object> {
        let rel_path = format!(
            "b/{bucket}/o/{object}",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC),
            object = percent_encode(format!("{}", params.object).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }

    /// Watch for changes on all objects in a bucket.
    pub async fn watch_all(
        &self,
        params: &ObjectsWatchAllParams,
        req: &Channel,
    ) -> Result<Channel> {
        let rel_path = format!(
            "b/{bucket}/o/watch",
            bucket = percent_encode(format!("{}", params.bucket).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }
}

/// The Storage Projects service represents the Projects resource.
pub struct ProjectsService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl ProjectsService {
    /// Create a new ProjectsService object. The easiest way to call this is
    /// wrapping the Authenticator into an `Rc`: `new(client.clone(),
    /// Rc::new(authenticator))`. This way, one authenticator can be shared
    /// among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> ProjectsService {
        ProjectsService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }
}

/// The Storage ProjectsHmacKeys service represents the ProjectsHmacKeys
/// resource.
pub struct ProjectsHmacKeysService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl ProjectsHmacKeysService {
    /// Create a new ProjectsHmacKeysService object. The easiest way to call
    /// this is wrapping the Authenticator into an `Rc`:
    /// `new(client.clone(), Rc::new(authenticator))`. This way, one
    /// authenticator can be shared among several services.
    pub fn new<A: 'static + DerefAuth>(client: TlsClient, auth: A) -> ProjectsHmacKeysService {
        ProjectsHmacKeysService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Creates a new HMAC key for the specified service account.
    pub async fn create(&self, params: &ProjectsHmacKeysCreateParams) -> Result<HmacKey> {
        let rel_path = format!(
            "projects/{projectId}/hmacKeys",
            projectId = percent_encode(
                format!("{}", params.project_id).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "POST", opt_request).await
    }

    /// Deletes an HMAC key.
    pub async fn delete(&self, params: &ProjectsHmacKeysDeleteParams) -> Result<()> {
        let rel_path = format!(
            "projects/{projectId}/hmacKeys/{accessId}",
            projectId = percent_encode(
                format!("{}", params.project_id).as_bytes(),
                NON_ALPHANUMERIC
            ),
            accessId = percent_encode(format!("{}", params.access_id).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "DELETE", opt_request).await
    }

    /// Retrieves an HMAC key's metadata
    pub async fn get(&self, params: &ProjectsHmacKeysGetParams) -> Result<HmacKeyMetadata> {
        let rel_path = format!(
            "projects/{projectId}/hmacKeys/{accessId}",
            projectId = percent_encode(
                format!("{}", params.project_id).as_bytes(),
                NON_ALPHANUMERIC
            ),
            accessId = percent_encode(format!("{}", params.access_id).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadOnly.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Retrieves a list of HMAC keys matching the criteria.
    pub async fn list(&self, params: &ProjectsHmacKeysListParams) -> Result<HmacKeysMetadata> {
        let rel_path = format!(
            "projects/{projectId}/hmacKeys",
            projectId = percent_encode(
                format!("{}", params.project_id).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadOnly.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }

    /// Updates the state of an HMAC key. See the HMAC Key resource descriptor
    /// for valid states.
    pub async fn update(
        &self,
        params: &ProjectsHmacKeysUpdateParams,
        req: &HmacKeyMetadata,
    ) -> Result<HmacKeyMetadata> {
        let rel_path = format!(
            "projects/{projectId}/hmacKeys/{accessId}",
            projectId = percent_encode(
                format!("{}", params.project_id).as_bytes(),
                NON_ALPHANUMERIC
            ),
            accessId = percent_encode(format!("{}", params.access_id).as_bytes(), NON_ALPHANUMERIC)
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageFullControl.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        let opt_request = Some(req);
        do_request(&self.client, &full_uri, &headers, "PUT", opt_request).await
    }
}

/// The Storage ProjectsServiceAccount service represents the
/// ProjectsServiceAccount resource.
pub struct ProjectsServiceAccountService {
    client: TlsClient,
    authenticator: Box<dyn 'static + DerefAuth>,
    scopes: Vec<String>,

    base_url: String,
    root_url: String,
}

impl ProjectsServiceAccountService {
    /// Create a new ProjectsServiceAccountService object. The easiest way to
    /// call this is wrapping the Authenticator into an `Rc`:
    /// `new(client.clone(), Rc::new(authenticator))`. This way, one
    /// authenticator can be shared among several services.
    pub fn new<A: 'static + DerefAuth>(
        client: TlsClient,
        auth: A,
    ) -> ProjectsServiceAccountService {
        ProjectsServiceAccountService {
            client,
            authenticator: Box::new(auth),
            scopes: vec![],
            base_url: "https://storage.googleapis.com/storage/v1/".into(),
            root_url: "https://storage.googleapis.com/".into(),
        }
    }

    /// Provide the base URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn base_url(&self) -> String {
        if self.base_url.ends_with("/") {
            return self.base_url.clone();
        }
        return self.base_url.clone() + "/";
    }
    /// Provide the root URL of this API. The returned URL is guaranteed to end
    /// with a '/'.
    fn root_url(&self) -> String {
        if self.root_url.ends_with("/") {
            return self.root_url.clone();
        }
        return self.root_url.clone();
    }
    /// Returns appropriate URLs for relative and absolute paths.
    fn format_path(&self, path: &str) -> String {
        if path.starts_with("/") {
            return self.root_url().trim_end_matches("/").to_string() + path;
        } else {
            return self.base_url() + path;
        }
    }

    #[cfg(test)]
    /// Override API URLs. `base` is the base path relative to which (relative)
    /// method paths are interpreted, whereas `root` is the URL relative to
    /// which absolute paths are interpreted.
    pub fn set_urls(&mut self, base: String, root: String) {
        self.base_url = base;
        self.root_url = root;
    }

    /// Explicitly select which scopes should be requested for authorization.
    /// Otherwise, a possibly too large scope will be requested.
    ///
    /// It is most convenient to supply a vec or slice of StorageScopes enum
    /// values.
    pub fn set_scopes<S: AsRef<str>, T: AsRef<[S]>>(&mut self, scopes: T) {
        self.scopes = scopes
            .as_ref()
            .into_iter()
            .map(|s| s.as_ref().to_string())
            .collect();
    }

    /// Get the email address of this project's Google Cloud Storage service
    /// account.
    pub async fn get(&self, params: &ProjectsServiceAccountGetParams) -> Result<ServiceAccount> {
        let rel_path = format!(
            "projects/{projectId}/serviceAccount",
            projectId = percent_encode(
                format!("{}", params.project_id).as_bytes(),
                NON_ALPHANUMERIC
            )
        );
        let path = self.format_path(rel_path.as_str());

        let mut headers = vec![];
        let tok;
        if self.scopes.is_empty() {
            let scopes = &[StorageScopes::DevstorageReadWrite.as_ref().to_string()];
            tok = self.authenticator.token(scopes).await?;
        } else {
            tok = self.authenticator.token(&self.scopes).await?;
        }
        headers.push((
            hyper::header::AUTHORIZATION,
            format!("Bearer {token}", token = tok.as_str()),
        ));

        let mut url_params = format!("?{params}", params = params);
        if let Some(ref api_params) = &params.storage_params {
            url_params.push_str(&format!("{}", api_params));
        }

        let full_uri = format!("{}{}", path, url_params);

        let opt_request: Option<&EmptyRequest> = None;
        do_request(&self.client, &full_uri, &headers, "GET", opt_request).await
    }
}
